<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>How PNADCperiods Works • PNADCperiods</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="How PNADCperiods Works">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">PNADCperiods</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/getting-started.html">Get Started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/download-and-prepare.html">Download and Prepare Data</a></li>
    <li><a class="dropdown-item" href="../articles/applied-examples.html">Applied Examples</a></li>
    <li><a class="dropdown-item" href="../articles/annual-poverty-analysis.html">Annual Poverty Analysis</a></li>
    <li><a class="dropdown-item" href="../articles/complex-survey-design.html">Complex Survey Design</a></li>
    <li><a class="dropdown-item" href="../articles/how-it-works.html">How PNADCperiods Works</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../articles/determination-rates-benchmark.html">Benchmark Report</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/antrologos/PNADCperiods/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>How PNADCperiods Works</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/antrologos/PNADCperiods/blob/HEAD/vignettes/how-it-works.Rmd" class="external-link"><code>vignettes/how-it-works.Rmd</code></a></small>
      <div class="d-none name"><code>how-it-works.Rmd</code></div>
    </div>

    
    
<!--
MAINTAINER NOTE:
This vignette uses eval=FALSE for all code chunks.
Pre-computed figures and tables are generated by:
  code/generate_how_it_works_figures.R

Figures are stored in: vignettes/figures/how-it-works/
Tables are stored in: output/vignette/tables/how-it-works/

To regenerate, run the generation script. The script caches intermediate
results in data/processed/ for faster subsequent runs.
-->
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>This vignette explains <strong>how the PNADCperiods algorithm
works</strong>: the methodology behind converting Brazil’s quarterly
PNADC survey into sub-quarterly time series with calibrated weights. For
practical usage examples, see the <a href="getting-started.html">Get
Started</a> vignette.</p>
<div class="section level3">
<h3 id="what-this-package-does">What This Package Does<a class="anchor" aria-label="anchor" href="#what-this-package-does"></a>
</h3>
<p>The <code>PNADCperiods</code> package transforms Brazil’s quarterly
PNADC (Pesquisa Nacional por Amostra de Domicilios Continua) survey data
into finer-grained time series for labor market, demographic, and
socioeconomic analysis. It addresses a fundamental challenge: PNADC
reports quarterly aggregates, but policy analysis often requires
understanding what happened within specific months, fortnights, or
weeks.</p>
<p><strong>Package capabilities:</strong></p>
<ol style="list-style-type: decimal">
<li>
<strong>Multi-granularity period identification</strong>: Determines
which specific time period each observation refers to
<ul>
<li>
<strong>Monthly</strong> (97% with full history, 94% with 8
quarters) - suitable for most analyses</li>
<li>
<strong>Fortnight</strong> (9% strict, up to 13.5% with
probabilistic strategy) - for short-term analysis</li>
<li>
<strong>Weekly</strong> (3.3% strict, up to 7.5% with probabilistic
strategy) - for high-frequency monitoring</li>
</ul>
</li>
<li>
<strong>Flexible weight calibration</strong>: Adjusts survey weights
for sub-quarterly estimates
<ul>
<li>Calibrates to official monthly population totals (SIDRA API)</li>
<li>Adaptive hierarchical raking (4/2/1 cell levels depending on sample
size)</li>
<li>Adaptive smoothing to remove quarterly artifacts (3/7/none
periods)</li>
</ul>
</li>
<li>
<strong>Dual data format support</strong>: Works with both quarterly
and annual PNADC releases
<ul>
<li>
<strong>Quarterly data</strong> (V1028 weights) - labor market
variables, all rotation groups</li>
<li>
<strong>Annual data</strong> (V1032 weights) - comprehensive income
(VD5008), single visit</li>
</ul>
</li>
</ol>
</div>
<div class="section level3">
<h3 id="why-this-matters">Why This Matters<a class="anchor" aria-label="anchor" href="#why-this-matters"></a>
</h3>
<p>Policy questions often require sub-quarterly precision that raw PNADC
data cannot provide:</p>
<ul>
<li>When exactly did unemployment spike during COVID-19? (March 2020
vs. January 2020)</li>
<li>How quickly did labor markets respond to minimum wage changes?
(month-to-month transitions)</li>
<li>What was poverty in December 2023 specifically? (not just Q4 2023
average)</li>
</ul>
<p>The algorithm exploits PNADC’s rotating panel design and birthday
information to recover this temporal precision. By identifying when each
household was actually interviewed within the quarter, we can construct
monthly time series with 97% of the original sample retained.</p>
</div>
<div class="section level3">
<h3 id="what-youll-learn">What You’ll Learn<a class="anchor" aria-label="anchor" href="#what-youll-learn"></a>
</h3>
<p>This vignette walks through the complete methodology:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Why stacked multi-quarter data matters</strong> - How
cross-quarter aggregation improves determination from ~70% to ~97%</li>
<li>
<strong>The core algorithm</strong> (8-step pipeline):
<ul>
<li>Valid interview date calculation (IBGE timing rules)</li>
<li>Birthday constraints to narrow date ranges</li>
<li>UPA-panel aggregation (households interviewed together)</li>
<li>Cross-quarter constraint propagation</li>
<li>Dynamic exception detection for edge cases</li>
</ul>
</li>
<li>
<strong>Nested identification hierarchy</strong> - How fortnights
require months, and weeks require fortnights</li>
<li>
<strong>Experimental strategies</strong> for improved fortnight/week
determination:
<ul>
<li>Probabilistic assignment for narrow date ranges</li>
<li>UPA aggregation leveraging 100% homogeneity finding</li>
</ul>
</li>
<li>
<strong>Weight calibration approaches</strong>:
<ul>
<li>Quarterly data: redistribute quarterly totals across 3 months</li>
<li>Annual data: redistribute yearly totals across 12 months</li>
<li>Fortnight/weekly data: simplified raking for smaller samples</li>
</ul>
</li>
<li>
<strong>Performance characteristics</strong> - Determination rates,
processing speed, data quality</li>
<li>
<strong>Best practices</strong> - Input data requirements, handling
indeterminate cases, validation</li>
</ol>
</div>
<div class="section level3">
<h3 id="prerequisites">Prerequisites<a class="anchor" aria-label="anchor" href="#prerequisites"></a>
</h3>
<p>This vignette assumes you’re already familiar with basic PNADC
concepts (UPA, rotation groups, survey weights) and have seen the
package in action via the <a href="getting-started.html">Get Started</a>
vignette. We focus here on <strong>understanding the
methodology</strong> rather than <strong>how to use the
functions</strong>.</p>
<p>If you’re looking for applied examples with real policy questions,
see the <a href="applied-examples.html">Applied Examples</a> vignette.
For poverty analysis using annual PNADC data, see <a href="annual-poverty-analysis.html">Annual Poverty Analysis</a>.</p>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="quick-reference">Quick Reference<a class="anchor" aria-label="anchor" href="#quick-reference"></a>
</h2>
<div class="section level3">
<h3 id="required-input-variables">Required Input Variables<a class="anchor" aria-label="anchor" href="#required-input-variables"></a>
</h3>
<p><strong>Minimum (for reference month identification):</strong></p>
<table class="table">
<thead><tr class="header">
<th>Column</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>Ano</code></td>
<td>Survey year</td>
</tr>
<tr class="even">
<td><code>Trimestre</code></td>
<td>Quarter (1-4)</td>
</tr>
<tr class="odd">
<td><code>UPA</code></td>
<td>Primary Sampling Unit</td>
</tr>
<tr class="even">
<td><code>V1014</code></td>
<td>Panel identifier</td>
</tr>
<tr class="odd">
<td><code>V1008</code></td>
<td>Household identifier</td>
</tr>
<tr class="even">
<td><code>V2008</code></td>
<td>Birth day (1-31, or 99 for unknown)</td>
</tr>
<tr class="odd">
<td><code>V20081</code></td>
<td>Birth month (1-12, or 99 for unknown)</td>
</tr>
<tr class="even">
<td><code>V20082</code></td>
<td>Birth year (or 9999 for unknown)</td>
</tr>
<tr class="odd">
<td><code>V2009</code></td>
<td>Age</td>
</tr>
</tbody>
</table>
<p><strong>Additional (for <code>calibrate = TRUE</code> in
<code><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods()</a></code>):</strong></p>
<table class="table">
<colgroup>
<col width="43%">
<col width="56%">
</colgroup>
<thead><tr class="header">
<th>Variable</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>V1028</code></td>
<td>Original quarterly survey weight</td>
</tr>
<tr class="even">
<td><code>V1032</code></td>
<td>Original annual survey weight (for annual data only)</td>
</tr>
<tr class="odd">
<td><code>UF</code></td>
<td>State code</td>
</tr>
<tr class="even">
<td><code>posest</code></td>
<td>Post-stratification cell</td>
</tr>
<tr class="odd">
<td><code>posest_sxi</code></td>
<td>Post-stratification group</td>
</tr>
<tr class="even">
<td><code>V2003</code></td>
<td>Person order in household (optional, used for sex-specific
calibration)</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="output-variables">Output Variables<a class="anchor" aria-label="anchor" href="#output-variables"></a>
</h3>
<p>The crosswalk returned by <code><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods()</a></code>
contains IBGE calendar-based output columns:</p>
<p><strong>Month columns:</strong></p>
<table class="table">
<colgroup>
<col width="34%">
<col width="20%">
<col width="44%">
</colgroup>
<thead><tr class="header">
<th>Variable</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>ref_month_start</code></td>
<td>Date</td>
<td>First day (Sunday) of the IBGE reference month</td>
</tr>
<tr class="even">
<td><code>ref_month_end</code></td>
<td>Date</td>
<td>Last day (Saturday) of the IBGE reference month</td>
</tr>
<tr class="odd">
<td><code>ref_month_weeks</code></td>
<td>Integer</td>
<td>Number of weeks in the reference month (4 or 5)</td>
</tr>
<tr class="even">
<td><code>ref_month_in_quarter</code></td>
<td>Integer</td>
<td>Position: 1, 2, 3, or NA if indeterminate</td>
</tr>
<tr class="odd">
<td><code>ref_month_yyyymm</code></td>
<td>Integer</td>
<td>YYYYMM format (e.g., 202301)</td>
</tr>
<tr class="even">
<td><code>determined_month</code></td>
<td>Logical</td>
<td>TRUE if month is definitively determined</td>
</tr>
</tbody>
</table>
<p><strong>Fortnight columns:</strong></p>
<table class="table">
<colgroup>
<col width="34%">
<col width="20%">
<col width="44%">
</colgroup>
<thead><tr class="header">
<th>Variable</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>ref_fortnight_start</code></td>
<td>Date</td>
<td>First day (Sunday) of the reference fortnight</td>
</tr>
<tr class="even">
<td><code>ref_fortnight_end</code></td>
<td>Date</td>
<td>Last day (Saturday) of the reference fortnight</td>
</tr>
<tr class="odd">
<td><code>ref_fortnight_in_quarter</code></td>
<td>Integer</td>
<td>Position: 1-6, or NA if indeterminate</td>
</tr>
<tr class="even">
<td><code>ref_fortnight_yyyyff</code></td>
<td>Integer</td>
<td>YYYYFF format (e.g., 202303 = 3rd fortnight of 2023)</td>
</tr>
<tr class="odd">
<td><code>determined_fortnight</code></td>
<td>Logical</td>
<td>TRUE if fortnight is definitively determined</td>
</tr>
</tbody>
</table>
<p><strong>Week columns:</strong></p>
<table class="table">
<colgroup>
<col width="34%">
<col width="20%">
<col width="44%">
</colgroup>
<thead><tr class="header">
<th>Variable</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>ref_week_start</code></td>
<td>Date</td>
<td>First day (Sunday) of the reference week</td>
</tr>
<tr class="even">
<td><code>ref_week_end</code></td>
<td>Date</td>
<td>Last day (Saturday) of the reference week</td>
</tr>
<tr class="odd">
<td><code>ref_week_in_quarter</code></td>
<td>Integer</td>
<td>Position: 1-13, or NA if indeterminate</td>
</tr>
<tr class="even">
<td><code>ref_week_yyyyww</code></td>
<td>Integer</td>
<td>YYYYWW format (e.g., 202315)</td>
</tr>
<tr class="odd">
<td><code>determined_week</code></td>
<td>Logical</td>
<td>TRUE if week is definitively determined</td>
</tr>
</tbody>
</table>
<p><strong>After applying <code><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods()</a></code> with
<code>calibrate = TRUE</code>:</strong></p>
<table class="table">
<colgroup>
<col width="34%">
<col width="20%">
<col width="44%">
</colgroup>
<thead><tr class="header">
<th>Variable</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>weight_monthly</code></td>
<td>Numeric</td>
<td>Monthly calibrated weight; NA for indeterminate</td>
</tr>
<tr class="even">
<td><code>weight_fortnight</code></td>
<td>Numeric</td>
<td>Fortnight calibrated weight (if
<code>calibration_unit = "fortnight"</code>)</td>
</tr>
<tr class="odd">
<td><code>weight_weekly</code></td>
<td>Numeric</td>
<td>Weekly calibrated weight (if
<code>calibration_unit = "week"</code>)</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="functions">Functions<a class="anchor" aria-label="anchor" href="#functions"></a>
</h3>
<table class="table">
<colgroup>
<col width="43%">
<col width="56%">
</colgroup>
<thead><tr class="header">
<th>Function</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods()</a></code></td>
<td>Main function: build crosswalk with months/fortnights/weeks</td>
</tr>
<tr class="even">
<td><code><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods()</a></code></td>
<td>Apply crosswalk + calibrate weights (quarterly or annual)</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/pnadc_experimental_periods.html">pnadc_experimental_periods()</a></code></td>
<td>Experimental strategies for improved fortnight/week
determination</td>
</tr>
<tr class="even">
<td><code>identify_reference_month()</code></td>
<td>Standalone reference month identification</td>
</tr>
<tr class="odd">
<td><code>identify_reference_fortnight()</code></td>
<td>Standalone fortnight (quinzena) identification</td>
</tr>
<tr class="even">
<td><code>identify_reference_week()</code></td>
<td>Standalone week identification</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/fetch_monthly_population.html">fetch_monthly_population()</a></code></td>
<td>Fetch population from SIDRA API</td>
</tr>
<tr class="even">
<td><code><a href="../reference/validate_pnadc.html">validate_pnadc()</a></code></td>
<td>Input data validation</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="performance-summary">Performance Summary<a class="anchor" aria-label="anchor" href="#performance-summary"></a>
</h3>
<table class="table">
<colgroup>
<col width="50%">
<col width="50%">
</colgroup>
<thead><tr class="header">
<th>Metric</th>
<th>Result</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Monthly determination rate</td>
<td>
<strong>97%</strong> (55Q full history), <strong>94%</strong> (8Q
benchmark)</td>
</tr>
<tr class="even">
<td>Fortnight determination rate (strict)</td>
<td>
<strong>8.9%</strong> (8Q), <strong>9.2%</strong> (55Q)</td>
</tr>
<tr class="odd">
<td>Weekly determination rate (strict)</td>
<td>
<strong>3.3%</strong> (all stacking levels)</td>
</tr>
<tr class="even">
<td>Processing time (basic mode)</td>
<td>
<strong>~2.5 minutes</strong> for 28.4M rows (~177,000
rows/sec)</td>
</tr>
<tr class="odd">
<td>Processing time (with weights)</td>
<td><strong>~5 minutes</strong></td>
</tr>
<tr class="even">
<td>Best period (2013-2019)</td>
<td>97-99% monthly determination</td>
</tr>
<tr class="odd">
<td>COVID period (2020-2021)</td>
<td>93-96% monthly determination</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="experimental-strategies-summary">Experimental Strategies Summary<a class="anchor" aria-label="anchor" href="#experimental-strategies-summary"></a>
</h3>
<p>The package includes experimental strategies to improve fortnight and
week determination for sensitivity analysis. These are accessed via
<code><a href="../reference/pnadc_experimental_periods.html">pnadc_experimental_periods()</a></code>:</p>
<table class="table">
<colgroup>
<col width="22%">
<col width="36%">
<col width="25%">
<col width="15%">
</colgroup>
<thead><tr class="header">
<th>Strategy</th>
<th>Fortnight Rate</th>
<th>Week Rate</th>
<th>Notes</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Strict (default)</td>
<td>8.9%</td>
<td>3.3%</td>
<td>Definitive determinations only</td>
</tr>
<tr class="even">
<td>+ Probabilistic (conf=0.9)</td>
<td><strong>13.5%</strong></td>
<td>3.6%</td>
<td>Conservative probabilistic assignments</td>
</tr>
<tr class="odd">
<td>+ Probabilistic (conf=0.8)</td>
<td>13.5%</td>
<td><strong>7.5%</strong></td>
<td>Maximum week coverage</td>
</tr>
<tr class="even">
<td>+ UPA Aggregation</td>
<td>8.9%</td>
<td>3.3%</td>
<td>Minimal improvement in practice</td>
</tr>
<tr class="odd">
<td>+ Both (conf=0.9)</td>
<td>13.5%</td>
<td>3.6%</td>
<td>Same as probabilistic alone</td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> Probabilistic strategy provides all the
improvement. UPA aggregation adds essentially nothing. Choose conf=0.9
for conservative analysis, conf=0.8 for maximum week rate.</p>
<p>See the <a href="#experimental-strategies">Experimental
Strategies</a> section for details.</p>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="why-stacked-data-matters">Why Stacked Data Matters<a class="anchor" aria-label="anchor" href="#why-stacked-data-matters"></a>
</h2>
<p>The algorithm achieves <strong>97% determination rate</strong> when
processing <strong>stacked multi-quarter data</strong> (full 55-quarter
history). If you process quarters individually, you’ll only get ~73%
determination.</p>
<p>The figure below shows how determination rate improves as more
quarters are stacked, computed from real PNADC data (2012-2025):</p>
<div class="float">
<img src="figures/how-it-works/fig-determination-rate.png" style="width:100.0%" alt="Determination rate improves with more stacked quarters"><div class="figcaption">Determination rate improves with more stacked
quarters</div>
</div>
<p><strong>Empirical determination rates by number of quarters
stacked</strong> (from real PNADC 2012-2025 data):</p>
<table class="table">
<thead><tr class="header">
<th>Quarters Stacked</th>
<th>Observations</th>
<th>Determination Rate</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>1 (single quarter)</td>
<td>566,873</td>
<td>73.0%</td>
</tr>
<tr class="even">
<td>2</td>
<td>1,133,889</td>
<td>88.2%</td>
</tr>
<tr class="odd">
<td>4 (1 year)</td>
<td>2,252,464</td>
<td>93.9%</td>
</tr>
<tr class="even">
<td>8 (2 years)</td>
<td>4,530,641</td>
<td>96.3%</td>
</tr>
<tr class="odd">
<td>12 (3 years)</td>
<td>6,828,144</td>
<td>97.1%</td>
</tr>
<tr class="even">
<td>20 (5 years)</td>
<td>11,391,346</td>
<td>97.3%</td>
</tr>
<tr class="odd">
<td>32 (8 years)</td>
<td>18,088,581</td>
<td><strong>97.4%</strong></td>
</tr>
<tr class="even">
<td>55 (full history)</td>
<td>28,395,273</td>
<td>97.0%</td>
</tr>
</tbody>
</table>
<p>Note that the rate peaks around 32 quarters and then stabilizes. This
occurs because the boundary quarters (first 4 and last 4 of any series)
have inherently lower rates due to incomplete panel coverage.</p>
<p><strong>Why does stacking help?</strong> PNADC uses a
<strong>rotating panel</strong> where each household (UPA + V1014) is
interviewed for 5 consecutive quarters. Crucially, the same household is
always interviewed in the <strong>same relative month position</strong>
(always month 1, always month 2, or always month 3).</p>
<p>This means birthday constraints from <strong>any quarter</strong> can
determine the month for <strong>all quarters</strong>:</p>
<pre><code>UPA=123456, V1014=1 appears in 5 quarters:

  2023-Q1: month_min=1, month_max=2 (ambiguous: Jan or Feb)
  2023-Q2: month_min=1, month_max=3 (ambiguous: Apr, May, or Jun)
  2023-Q3: month_min=2, month_max=2 (DETERMINED: August)  &lt;- Birthday constraint!
  2023-Q4: month_min=1, month_max=2 (ambiguous: Oct or Nov)
  2024-Q1: month_min=2, month_max=3 (ambiguous: Feb or Mar)

Cross-quarter aggregation:
  upa_month_min = max(1, 1, 2, 1, 2) = 2
  upa_month_max = min(2, 3, 2, 2, 3) = 2

Result: ALL 5 quarters -&gt; ref_month_in_quarter = 2</code></pre>
<p><strong>Recommended</strong>: Stack at least 2 years (8 quarters) of
data before calling <code><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods()</a></code> to achieve
&gt;96% determination.</p>
<hr>
</div>
<div class="section level2">
<h2 id="the-algorithm-explained">The Algorithm Explained<a class="anchor" aria-label="anchor" href="#the-algorithm-explained"></a>
</h2>
<p>This section details how the package identifies reference periods
(months, fortnights, and weeks) for each observation. The algorithm
shares initial computation steps across all three period types, then
diverges based on each period’s aggregation scope.</p>
<div class="section level3">
<h3 id="overview-diagram">Overview Diagram<a class="anchor" aria-label="anchor" href="#overview-diagram"></a>
</h3>
<p>The reference period identification follows a pipeline with shared
initial steps and period-specific aggregation:</p>
<pre><code>+-----------------------------------------------------------------------------+
|                    REFERENCE PERIOD IDENTIFICATION PIPELINE                  |
|                       (Months, Fortnights, and Weeks)                        |
+-----------------------------------------------------------------------------+

INPUTS (per observation):
+--------------+  +--------------+  +--------------+  +--------------+
|     Year     |  |    Quarter   |  |    Birthday  |  |      Age     |
|    (Ano)     |  |  (Trimestre) |  |  (V2008/1/2) |  |    (V2009)   |
+--------------+  +--------------+  +--------------+  +--------------+
        |                |                  |                 |
        +----------------+------------------+-----------------+
                                    |
                                    v
+-----------------------------------------------------------------------------+
|                        SHARED COMPUTATION (All Periods)                      |
+-----------------------------------------------------------------------------+
|                                                                              |
|  STEP 1: Calculate Valid Interview Saturdays (IBGE Rules)                    |
|          Output: date_min, date_max for each quarter                         |
|                                                                              |
|  STEP 2: Apply Birthday Constraints                                          |
|          Narrow date window using age vs birth year comparison               |
|                                                                              |
|  STEP 3: Convert Dates to Period Positions                                   |
|          Compute: month_min/max, fortnight_min/max, week_min/max             |
|                                                                              |
+-----------------------------------------------------------------------------+
                                    |
                                    v
+-----------------------------------------------------------------------------+
|               NESTED IDENTIFICATION (enforced by construction)               |
+-----------------------------------------------------------------------------+
|                                                                              |
|  PHASE 1: MONTH PIPELINE (Steps 4-7)                                         |
|  |-- Step 4: Aggregate at (UPA, V1014) level                                 |
|  |-- Step 5: CROSS-QUARTER aggregation across ALL quarters                   |
|  |-- Step 6: Dynamic exception detection                                     |
|  +-- Step 7: Final month assignment                                          |
|  +-- Determination: 97% (55Q), 94% (8Q)                                      |
|                         |                                                    |
|                         v (only if month determined)                         |
|  PHASE 2: FORTNIGHT PIPELINE                                                 |
|  |-- Step 4: Aggregate at (Ano, Trimestre, UPA, V1008) level                 |
|  |-- NO cross-quarter aggregation possible                                   |
|  +-- Step 5: Final fortnight assignment                                      |
|  +-- Determination: 8.9% (strict)                                            |
|                         |                                                    |
|                         v (only if fortnight determined)                     |
|  PHASE 3: WEEK PIPELINE                                                      |
|  |-- Step 4: Aggregate at (Ano, Trimestre, UPA, V1008) level                 |
|  |-- NO cross-quarter aggregation possible                                   |
|  +-- Step 5: Final week assignment                                           |
|  +-- Determination: 3.3% (strict)                                            |
|                                                                              |
+-----------------------------------------------------------------------------+
                                    |
                                    v
+-----------------------------------------------------------------------------+
| OUTPUT (IBGE calendar-based):                                                |
| - Month:     ref_month_start/end (Date), ref_month_weeks, ref_month_yyyymm   |
| - Fortnight: ref_fortnight_start/end (Date), ref_fortnight_yyyyff            |
| - Week:      ref_week_start/end (Date), ref_week_yyyyww                      |
| - Flags:     determined_month, determined_fortnight, determined_week         |
+-----------------------------------------------------------------------------+</code></pre>
<p><strong>Key insight</strong>: The identification is <strong>nested by
construction</strong> - fortnights can only be identified if the month
is already determined, and weeks can only be identified if the fortnight
is already determined. This guarantee is built into the algorithm, not
enforced by post-hoc cleanup. Additionally, <strong>months benefit from
cross-quarter aggregation</strong> (Step 5), while fortnights and weeks
cannot aggregate constraints across quarters. This explains why the
monthly determination rate (97% with full history, 94% with 8 quarters)
far exceeds fortnights (8.9% strict) and weeks (3.3% strict).</p>
<hr>
</div>
<div class="section level3">
<h3 id="shared-computation-steps-1-3">Shared Computation (Steps 1-3)<a class="anchor" aria-label="anchor" href="#shared-computation-steps-1-3"></a>
</h3>
<p>The following three steps are computed once and shared across all
period types (months, fortnights, and weeks).</p>
<div class="section level4">
<h4 id="step-1-valid-interview-saturdays-ibge-rules">Step 1: Valid Interview Saturdays (IBGE Rules)<a class="anchor" aria-label="anchor" href="#step-1-valid-interview-saturdays-ibge-rules"></a>
</h4>
<p>IBGE defines that a reference week belongs to a month only if it has
at least <strong>4 days within that month</strong>. Since reference
weeks end on Saturdays, we examine the Saturdays of each month to
determine valid interview dates.</p>
<p><strong>How we calculate the first valid Saturday:</strong></p>
<pre><code>first_saturday_day = day of the first Saturday of the month
if first_saturday_day &gt;= 4:
    use this Saturday (it has enough days in the month)
else:
    use the second Saturday (first_saturday_day + 7)</code></pre>
<p><strong>Example for Q1 2023:</strong></p>
<pre><code>JANUARY 2023:
  Sun  Mon  Tue  Wed  Thu  Fri  SAT
   1    2    3    4    5    6   [7]  &lt;- First Saturday is day 7
                                     7 &gt;= 4? YES -&gt; Valid! (7 days in January)

FEBRUARY 2023:
  Wed  Thu  Fri  SAT  ...
   1    2    3   [4]              &lt;- First Saturday is day 4
                                  4 &gt;= 4? YES -&gt; Valid! (4 days in February)

APRIL 2023:
  SAT  Sun  Mon  Tue  ...
  [1]   2    3    4              &lt;- First Saturday is day 1
                                  1 &gt;= 4? NO -&gt; Skip to second Saturday!
  Fri  SAT  Sun  ...
   7   [8]   9                   &lt;- Use day 8 instead</code></pre>
<p>The valid Saturday calculation defines the <strong>possible interview
date range</strong> for the quarter: - <code>date_min</code> = First
valid Saturday of Month 1 - <code>date_max</code> = First valid Saturday
of Month 3 + 21 days</p>
<hr>
</div>
</div>
<div class="section level3">
<h3 id="step-2-birthday-constraints">Step 2: Birthday Constraints<a class="anchor" aria-label="anchor" href="#step-2-birthday-constraints"></a>
</h3>
<p>IBGE calculates age precisely using the exact birthdate and the
interview reference date (most persons report birthdates). In other
words, IBGE <strong>calculates age on the Saturday</strong> that ends
the reference week of the interview.</p>
<p>By comparing the calculated age to the birth year, we can determine
whether the interview (i.e., the reference date) occurred before or
after the person’s birthday that year. This allows us to further narrow
down the possible interview date window.</p>
<pre><code>visit_before_birthday = (Survey_Year - Birth_Year) - Calculated_Age

If = 0: Interview was AFTER birthday (person already celebrated this year)
If = 1: Interview was BEFORE birthday (birthday hasn't happened yet)</code></pre>
<p><strong>Example: Interview AFTER birthday</strong></p>
<pre><code>Person: Born March 15, 1990
Survey Year and quarter: 2023 Q1
Calculated Age: 33

Check age: 2023 - 1990 = 33
           33 - 33 = 0  -&gt; Interview was AFTER March 15, 2023

Check first Saturday on or after birthday:
           first_Saturday_on_or_after(March 15) = March 18, 2023

New date constraints:
            date_min = max(date_min, first_Saturday_on_or_after(March 15))
            date_min = max(Jan 7, March 18) = March 18

This person can only have been interviewed in MARCH (Month 3 of Q1).</code></pre>
<p><strong>Example: Interview BEFORE birthday</strong></p>
<pre><code>Person: Born February 17, 1990
Survey Year and quarter: 2023 Q1
Calculated Age: 32

Check age: 2023 - 1990 = 33
           33 - 32 = 1  -&gt; Interview was BEFORE February 17, 2023

Check first Saturday on or after birthday:
           first_Saturday_on_or_after(February 17) = February 18, 2023 (Sat)
           Saturday_before = February 18 - 7 = February 11, 2023

Constraint: date_max = min(date_max, Saturday_before(birthday))
            date_max = min(March 25, February 11) = February 11

This person can only have been interviewed in JANUARY or early FEBRUARY.</code></pre>
<p><strong>Unknown birthdays</strong>: When V2008=99, V20081=99, or
V20082=9999, that person’s birthday cannot constrain the date. However,
they may still be determined through aggregation at the UPA-Panel level
(Step 4) or cross-quarter aggregation (Step 5).</p>
<hr>
</div>
<div class="section level3">
<h3 id="step-3-date-to-period-position">Step 3: Date to Period Position<a class="anchor" aria-label="anchor" href="#step-3-date-to-period-position"></a>
</h3>
<p>Transform the date window [date_min, date_max] into period positions.
This step works similarly for all three granularities:</p>
<p><strong>Month positions (1, 2, or 3):</strong></p>
<pre><code>For date_min: if day &lt;= 3 AND not in first month of quarter:
              subtract 1 from month position

For date_max: if day &lt;= 3:
              use the month of (date - 3 days) instead</code></pre>
<p><strong>Boundary handling</strong>: Interviews on days 1-3 of a month
typically belong to a reference week that started in the previous
month.</p>
<p><strong>Fortnight positions (1-6):</strong></p>
<p>After determining the month position, fortnights are calculated
as:</p>
<pre><code>fortnight_pos = (month_pos - 1) * 2 + half_of_month
  where half_of_month = 1 if day &lt;= 15, else 2</code></pre>
<table class="table">
<thead><tr class="header">
<th>Month</th>
<th>Days 1-15</th>
<th>Days 16-31</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Fortnight 1</td>
<td>Fortnight 2</td>
</tr>
<tr class="even">
<td>2</td>
<td>Fortnight 3</td>
<td>Fortnight 4</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Fortnight 5</td>
<td>Fortnight 6</td>
</tr>
</tbody>
</table>
<p><strong>Week positions (IBGE calendar):</strong></p>
<p>Weeks follow the IBGE calendar convention where weeks run
<strong>Sunday to Saturday</strong>. The first week of a month must have
at least 4 days in that month:</p>
<pre><code>For each date:
  ref_week_yyyyww = Year * 100 + week_number_in_year

IBGE weeks:
- Start on Sunday, end on Saturday
- First week of month must have &gt;= 4 days in that month
- Reference months contain either 4 or 5 complete weeks</code></pre>
<p>The resulting period positions feed into Step 4 (aggregation), which
differs by period type. See the separate pipelines below for months,
fortnights, and weeks.</p>
<hr>
</div>
<div class="section level3">
<h3 id="month-identification-pipeline-steps-4-7">Month Identification Pipeline (Steps 4-7)<a class="anchor" aria-label="anchor" href="#month-identification-pipeline-steps-4-7"></a>
</h3>
<p>The month identification pipeline uses cross-quarter aggregation to
achieve ~97% determination. This high rate is possible because the same
UPA-V1014 panel group is always interviewed in the same relative month
across all their quarterly visits.</p>
<div class="section level4">
<h4 id="step-4-upa-panel-aggregation">Step 4: UPA-Panel Aggregation<a class="anchor" aria-label="anchor" href="#step-4-upa-panel-aggregation"></a>
</h4>
<p>All people in the same <strong>UPA + V1014</strong> are interviewed
together in the <strong>same reference month</strong>. Take the
intersection:</p>
<pre><code>upa_month_min = MAX of all individual month_min_pos
upa_month_max = MIN of all individual month_max_pos</code></pre>
<p><strong>Example:</strong></p>
<pre><code>A household located at UPA=123456 and member of the Panel group V1014=1 has 3 members:

Person A: month_min=1, month_max=2 (could be Jan or Feb)
Person B: month_min=1, month_max=3 (could be Jan, Feb, or Mar)
Person C: month_min=2, month_max=3 (could be Feb or Mar)

Aggregation:
  upa_month_min = max(1, 1, 2) = 2
  upa_month_max = min(2, 3, 3) = 2

Result: min=2, max=2 -&gt; Reference month is FEBRUARY!

Visual:
              Jan    Feb    Mar
Person A:     [=========]
Person B:     [============]
Person C:            [========]
Intersection:        [==]      &lt;- Only February satisfies all</code></pre>
<p><strong>Note</strong>: Fortnights and weeks use a different
aggregation key - see the Fortnight and Week Identification section
below.</p>
</div>
<div class="section level4">
<h4 id="step-5-cross-quarter-aggregation">Step 5: Cross-Quarter Aggregation<a class="anchor" aria-label="anchor" href="#step-5-cross-quarter-aggregation"></a>
</h4>
<p>Since the relative month position is constant across quarters,
constraints from <strong>any</strong> quarter apply to
<strong>all</strong> quarters:</p>
<pre><code>For each (UPA, V1014) group across ALL quarters:
  upa_month_min = MAX of all month_min_pos from all quarters
  upa_month_max = MIN of all month_max_pos from all quarters</code></pre>
<p>This is why processing stacked data improves determination from ~70%
(single quarter) to 94% (8 quarters) to 97% (full history).</p>
<p><strong>Critical distinction</strong>: This cross-quarter aggregation
is what makes monthly determination so effective (94-97%), but it
<strong>cannot be applied to fortnights or weeks</strong>. Even though a
household is always interviewed in the same relative month (e.g., always
month 2), the specific fortnight or week within that month varies by
quarter. Therefore, fortnight and week constraints must be evaluated
within each quarter independently, resulting in much lower determination
rates (8.9% for fortnights, 3.3% for weeks).</p>
</div>
<div class="section level4">
<h4 id="step-6-dynamic-exception-detection">Step 6: Dynamic Exception Detection<a class="anchor" aria-label="anchor" href="#step-6-dynamic-exception-detection"></a>
</h4>
<p>In some quarters, the standard rule (first reference week with at
least 4 days) may produce impossible results, such as
<code>upa_month_min &gt; upa_month_max</code>. Quarters in which this
happens are flagged as needing an exception. We then implement an
<strong>alternative rule</strong>: first reference week with at least 3
days.</p>
<p><strong>How dynamic detection works</strong>: The algorithm
calculates month positions using both rules simultaneously:</p>
<table class="table">
<thead><tr class="header">
<th>Rule</th>
<th>First reference week</th>
<th>Day Threshold</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Standard</td>
<td>&gt;=4 days in month</td>
<td>day &lt;= 3</td>
</tr>
<tr class="even">
<td>Alternative</td>
<td>&gt;=3 days in month</td>
<td>day &lt;= 2</td>
</tr>
</tbody>
</table>
<p>Exceptions are detected and applied at the month level within each
quarter. For example, in 2016q3, only month 3 (September) needs the
exception - months 1 and 2 use the standard rule. Here’s why: under the
standard rule, September’s first valid Saturday would be September 10th
(since September 3rd has only 3 days in the month). But some UPA-V1014
groups have constraints that require September 3rd to be valid. The
exception rule (&gt;=3 days instead of &gt;=4) makes September 3rd valid
for these groups, assigning the week of August 28th-September 3rd to
September’s reference month rather than August’s.</p>
<p>The algorithm proceeds as follows:</p>
<pre><code>For each UPA-V1014:
  1. Calculate upa_month_min/max using STANDARD rules
  2. Also calculate alt_upa_month_min/max using ALTERNATIVE rules
  3. Check if exception is needed. ALL conditions must be true:
     a) Standard produces impossible result: upa_month_min &gt; upa_month_max
     b) Alternative would work: alt_upa_month_min &lt;= alt_upa_month_max
     c) Individual's constraint is the binding one that could be relaxed
        (the individual's bound equals the UPA bound that would change)
  4. Determine WHICH month within the quarter needs the exception:
     - requires_exc_m1: Exception needed for month 1
     - requires_exc_m2: Exception needed for month 2
     - requires_exc_m3: Exception needed for month 3
  5. PROPAGATE: If ANY UPA in the quarter needs exception for a month,
     apply that exception to ALL observations in that quarter</code></pre>
<p>Exception quarters are detected automatically. Examples found in
2012-2025 data: 2016q3, 2016q4, 2017q2, 2022q3, 2023q2, 2024q1. The
algorithm will detect any new exceptions in future data.</p>
</div>
<div class="section level4">
<h4 id="step-7-final-assignment">Step 7: Final Assignment<a class="anchor" aria-label="anchor" href="#step-7-final-assignment"></a>
</h4>
<p>After applying exceptions: if
<code>upa_month_min == upa_month_max</code>, the reference month is
determined. Otherwise, it remains NA.</p>
<p><strong>What makes observations indeterminate (~3%)?</strong></p>
<p>This occurs when the available birth date information in a (UPA,
V1014) group is insufficient to narrow down the possibilities to a
single month. Several factors contribute:</p>
<ul>
<li>
<strong>Incomplete panel coverage</strong>: Some UPAs may have fewer
than the expected 5 visits in the dataset. The first and last 4 quarters
of any consecutive series will naturally have more UPAs with incomplete
visit histories due to the rotating panel design.</li>
<li>
<strong>Unit non-response</strong>: The survey targets 14 households
per UPA each quarter, but non-response reduces this. Fewer responding
households means fewer birthday constraints to narrow down the
month.</li>
<li>
<strong>Small household sizes</strong>: Households with fewer
members provide fewer birthday constraints.</li>
<li>
<strong>Missing birth dates</strong>: Not all respondents report
their date of birth. Higher item non-response reduces the available
constraints.</li>
<li>
<strong>Uninformative birthdays</strong>: Some reported birth dates
don’t help distinguish between months (e.g., birthdays outside the
quarter’s interview window).</li>
</ul>
<p>Indeterminate observations are then removed from monthly analysis (if
<code>keep_all = FALSE</code>) or assigned <code>month = NA</code> and
<code>weight_monthly = NA</code> (if <code>keep_all = TRUE</code>).</p>
<hr>
</div>
</div>
<div class="section level3">
<h3 id="fortnight-and-week-identification-pipeline-steps-4-5">Fortnight and Week Identification Pipeline (Steps 4-5)<a class="anchor" aria-label="anchor" href="#fortnight-and-week-identification-pipeline-steps-4-5"></a>
</h3>
<p>The package also identifies <strong>fortnights</strong> (quinzenas)
and <strong>weeks</strong> within each quarter. These use the same
shared computation (Steps 1-3) as months, but with a critical
difference: <strong>they cannot aggregate across quarters</strong>,
resulting in much lower determination rates.</p>
<div class="section level4">
<h4 id="nested-identification-hierarchy">Nested Identification Hierarchy<a class="anchor" aria-label="anchor" href="#nested-identification-hierarchy"></a>
</h4>
<p>The identification follows a strict nesting hierarchy, enforced
<strong>by construction</strong> in the algorithm:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Fortnights require months</strong>: A fortnight can only be
determined if the reference month is already determined</li>
<li>
<strong>Weeks require fortnights</strong>: A week can only be
determined if the reference fortnight is already determined</li>
</ol>
<p>This nesting is not a post-hoc cleanup - it’s built into the
algorithm. The package tests verify this guarantee holds for all
observations.</p>
</div>
<div class="section level4">
<h4 id="why-lower-determination-rates">Why Lower Determination Rates?<a class="anchor" aria-label="anchor" href="#why-lower-determination-rates"></a>
</h4>
<table class="table">
<colgroup>
<col width="13%">
<col width="22%">
<col width="32%">
<col width="32%">
</colgroup>
<thead><tr class="header">
<th>Period</th>
<th>Strict Rate</th>
<th>With Experimental</th>
<th>Aggregation Scope</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><strong>Month</strong></td>
<td>94-97%</td>
<td>97% (probabilistic)</td>
<td>Cross-quarter (UPA, V1014)</td>
</tr>
<tr class="even">
<td><strong>Fortnight</strong></td>
<td>8.9%</td>
<td>13.5% (probabilistic)</td>
<td>Within-quarter (Ano, Trimestre, UPA, V1008)</td>
</tr>
<tr class="odd">
<td><strong>Week</strong></td>
<td>3.3%</td>
<td>7.5% (prob conf=0.8)</td>
<td>Within-quarter (Ano, Trimestre, UPA, V1008)</td>
</tr>
</tbody>
</table>
<p>The key difference: <strong>months benefit from cross-quarter
aggregation</strong> (Step 5), while fortnights and weeks cannot.</p>
<p><strong>Why can’t fortnights/weeks aggregate across
quarters?</strong></p>
<ul>
<li>A household’s <strong>relative month position</strong> is constant:
if interviewed in month 2 of Q1, they’re always interviewed in month 2
of every quarter.</li>
<li>But the <strong>specific fortnight or week</strong> varies: even if
always in month 2, they might be in fortnight 3 in Q1 but fortnight 4 in
Q2.</li>
<li>Therefore, fortnight/week constraints from different quarters cannot
be combined.</li>
</ul>
</div>
<div class="section level4">
<h4 id="fortnight-identification-algorithm">Fortnight Identification Algorithm<a class="anchor" aria-label="anchor" href="#fortnight-identification-algorithm"></a>
</h4>
<p>Fortnights divide the quarter into 6 periods (2 per month):</p>
<pre><code>Quarter structure:
Month 1: Fortnight 1, Fortnight 2
Month 2: Fortnight 3, Fortnight 4
Month 3: Fortnight 5, Fortnight 6</code></pre>
<p>The algorithm follows the same Steps 1-4 as months, but:</p>
<p><strong>Step 3 (Fortnight version)</strong>: Convert dates to
fortnight positions (1-6)</p>
<pre><code>For each date in the quarter:
  1. Determine which month (1, 2, or 3)
  2. Determine if first or second half of month:
     - Days 1-15: First fortnight
     - Days 16+: Second fortnight
  3. Calculate position: (month - 1) * 2 + half</code></pre>
<p><strong>Step 4 (Fortnight version)</strong>: Aggregate at household
level <strong>within quarter</strong></p>
<pre><code>For each (Ano, Trimestre, UPA, V1008) group:
  hh_fortnight_min = max(all individual fortnight_min_pos)
  hh_fortnight_max = min(all individual fortnight_max_pos)

If hh_fortnight_min == hh_fortnight_max -&gt; DETERMINED</code></pre>
<p><strong>No Step 5</strong>: Fortnights cannot use cross-quarter
aggregation.</p>
<p><strong>Output variables:</strong></p>
<table class="table">
<colgroup>
<col width="43%">
<col width="56%">
</colgroup>
<thead><tr class="header">
<th>Variable</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>ref_fortnight_start</code></td>
<td>First day (Sunday) of reference fortnight</td>
</tr>
<tr class="even">
<td><code>ref_fortnight_end</code></td>
<td>Last day (Saturday) of reference fortnight</td>
</tr>
<tr class="odd">
<td><code>ref_fortnight_in_quarter</code></td>
<td>Position 1-6, or NA if indeterminate</td>
</tr>
<tr class="even">
<td><code>ref_fortnight_yyyyff</code></td>
<td>YYYYFF format (e.g., 202303 = 3rd fortnight of 2023, i.e., Feb
1-15)</td>
</tr>
<tr class="odd">
<td><code>determined_fortnight</code></td>
<td>Logical: TRUE if determined</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="week-identification-algorithm">Week Identification Algorithm<a class="anchor" aria-label="anchor" href="#week-identification-algorithm"></a>
</h4>
<p>Weeks divide the quarter into approximately 13 periods:</p>
<pre><code>Quarter structure (example):
Month 1: Weeks 1-4 (or 5, depending on calendar)
Month 2: Weeks 5-8 (or 4-8)
Month 3: Weeks 9-13 (or 8-13)</code></pre>
<p>The algorithm uses the IBGE calendar (Sunday-Saturday weeks):</p>
<p><strong>Step 3 (Week version)</strong>: Convert dates to week
numbers</p>
<pre><code>For each date:
  ref_week_yyyyww = Year * 100 + week_number

IBGE weeks:
- Run Sunday to Saturday
- First week of month must have &gt;= 4 days in that month</code></pre>
<p><strong>Step 4 (Week version)</strong>: Aggregate at household level
<strong>within quarter</strong></p>
<pre><code>For each (Ano, Trimestre, UPA, V1008) group:
  hh_week_min = max(all individual week_min_yyyyww)
  hh_week_max = min(all individual week_max_yyyyww)

If hh_week_min == hh_week_max -&gt; DETERMINED</code></pre>
<p><strong>Output variables:</strong></p>
<table class="table">
<thead><tr class="header">
<th>Variable</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>ref_week_start</code></td>
<td>First day (Sunday) of reference week</td>
</tr>
<tr class="even">
<td><code>ref_week_end</code></td>
<td>Last day (Saturday) of reference week</td>
</tr>
<tr class="odd">
<td><code>ref_week_in_quarter</code></td>
<td>Position 1-13, or NA if indeterminate</td>
</tr>
<tr class="even">
<td><code>ref_week_yyyyww</code></td>
<td>YYYYWW format (e.g., 202315 = week 15 of 2023)</td>
</tr>
<tr class="odd">
<td><code>determined_week</code></td>
<td>Logical: TRUE if determined</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="practical-implications">Practical Implications<a class="anchor" aria-label="anchor" href="#practical-implications"></a>
</h4>
<p><strong>When to use each granularity:</strong></p>
<table class="table">
<colgroup>
<col width="23%">
<col width="23%">
<col width="33%">
<col width="19%">
</colgroup>
<thead><tr class="header">
<th>Granularity</th>
<th>Strict Rate</th>
<th>With Experimental</th>
<th>Use Cases</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><strong>Monthly</strong></td>
<td>94-97%</td>
<td>97% (probabilistic)</td>
<td>Most analyses: labor market trends, poverty dynamics</td>
</tr>
<tr class="even">
<td><strong>Fortnight</strong></td>
<td>8.9%</td>
<td>13.5% (probabilistic)</td>
<td>Short-term shock analysis</td>
</tr>
<tr class="odd">
<td><strong>Weekly</strong></td>
<td>3.3%</td>
<td>7.5% (prob conf=0.8)</td>
<td>High-frequency monitoring</td>
</tr>
</tbody>
</table>
<p><strong>Important considerations:</strong></p>
<ol style="list-style-type: decimal">
<li><p><strong>Sample size decreases rapidly</strong>: With strict
determination only, fortnight (8.9%) and week (3.3%) provide small
samples. Experimental strategies can moderately increase these
rates.</p></li>
<li><p><strong>Experimental strategies available</strong>: The
<code><a href="../reference/pnadc_experimental_periods.html">pnadc_experimental_periods()</a></code> function provides
probabilistic assignment (effective) and UPA aggregation (minimal
improvement) strategies that can increase fortnight determination to
13.5% and week to 7.5% (conf=0.8). See the <a href="#experimental-strategies">Experimental Strategies</a>
section.</p></li>
<li><p><strong>Weight calibration adapts</strong>: The package
automatically uses simplified raking (fewer cell levels) for
fortnights/weeks to handle smaller samples.</p></li>
</ol>
</div>
<div class="section level4">
<h4 id="usage-example">Usage Example<a class="anchor" aria-label="anchor" href="#usage-example"></a>
</h4>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Build crosswalk with all period types</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Check determination rates</span></span>
<span><span class="va">crosswalk</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  n_obs <span class="op">=</span> <span class="va">.N</span>,</span>
<span>  det_month <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_month</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  det_fortnight <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_fortnight</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  det_week <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_week</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">Ano</span>, <span class="va">Trimestre</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># For fortnight analysis, filter to determined observations</span></span>
<span><span class="va">fortnight_data</span> <span class="op">&lt;-</span> <span class="va">crosswalk</span><span class="op">[</span><span class="va">determined_fortnight</span> <span class="op">==</span> <span class="cn">TRUE</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">fortnight_data</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">crosswalk</span><span class="op">)</span>  <span class="co"># ~8.9%</span></span>
<span></span>
<span><span class="co"># Apply crosswalk with fortnight calibration</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_data</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"fortnight"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Output (from real PNADC 2012-2025 data):</p>
<pre><code>Building reference period crosswalk...
  Preprocessing data (shared computation)...
  Converting date bounds to period positions...
  Aggregating constraints and determining periods...
  Applying exception rules...
  Assigning reference periods...
  Building crosswalk...

Crosswalk complete:
  - 9,598,723 unique household-quarter observations
  - Month determination: 96.69%
  - Fortnight determination: 7.64%
  - Week determination: 1.54%

# Sample determination rates by quarter (2023):
     Ano Trimestre   n_obs det_month det_fortnight det_week
   &lt;int&gt;     &lt;int&gt;   &lt;int&gt;     &lt;num&gt;         &lt;num&gt;    &lt;num&gt;
1:  2023         1  169879     0.954         0.071    0.017
2:  2023         2  171776     0.960         0.071    0.006
3:  2023         3  175418     0.965         0.071    0.017
4:  2023         4  173676     0.968         0.071    0.017</code></pre>
<hr>
</div>
</div>
</div>
<div class="section level2">
<h2 id="experimental-strategies">Experimental Strategies<a class="anchor" aria-label="anchor" href="#experimental-strategies"></a>
</h2>
<p>The standard algorithm produces strict (definitive) determination
rates of 8.9% for fortnights and 3.3% for weeks. For applications
requiring larger sub-monthly samples, the package provides
<strong>experimental strategies</strong> that can moderately increase
these rates.</p>
<blockquote>
<p><strong>Important</strong>: Experimental strategies produce “likely”
assignments based on additional assumptions. They are intended for
sensitivity analysis, robustness checks, and research purposes - not for
replacing strict determination in rigorous analysis.</p>
</blockquote>
<div class="section level3">
<h3 id="overview-of-experimental-strategies">Overview of Experimental Strategies<a class="anchor" aria-label="anchor" href="#overview-of-experimental-strategies"></a>
</h3>
<p>The <code><a href="../reference/pnadc_experimental_periods.html">pnadc_experimental_periods()</a></code> function provides two
strategies that can be used individually or combined:</p>
<table class="table">
<colgroup>
<col width="16%">
<col width="18%">
<col width="36%">
<col width="29%">
</colgroup>
<thead><tr class="header">
<th>Strategy</th>
<th>Mechanism</th>
<th>Fortnight Improvement</th>
<th>Week Improvement</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>
<strong>Probabilistic</strong> (conf=0.9)</td>
<td>For 2-period ranges, assign the more likely period</td>
<td>8.9% → <strong>13.5%</strong> (+4.6 pp)</td>
<td>3.3% → 3.6% (+0.3 pp)</td>
</tr>
<tr class="even">
<td>
<strong>Probabilistic</strong> (conf=0.8)</td>
<td>Same as above, lower confidence threshold</td>
<td>8.9% → 13.5% (+4.6 pp)</td>
<td>3.3% → <strong>7.5%</strong> (+4.2 pp)</td>
</tr>
<tr class="odd">
<td><strong>UPA Aggregation</strong></td>
<td>Propagate determined periods to other households in UPA</td>
<td>8.9% → 8.9% (0 pp)</td>
<td>3.3% → 3.3% (0 pp)</td>
</tr>
<tr class="even">
<td><strong>Both</strong></td>
<td>Apply both strategies sequentially</td>
<td>Same as probabilistic alone</td>
<td>Same as probabilistic alone</td>
</tr>
</tbody>
</table>
<p><strong>Key Finding:</strong> Probabilistic strategy provides all the
improvement. UPA aggregation adds essentially nothing in practice.
Choose confidence threshold based on your needs: 0.9 for conservative
analysis, 0.8 for maximum week coverage.</p>
<div class="float">
<img src="figures/how-it-works/fig-experimental-strategies.png" style="width:100.0%" alt="Experimental strategies: Probabilistic provides all gains"><div class="figcaption">Experimental strategies: Probabilistic provides
all gains</div>
</div>
</div>
<div class="section level3">
<h3 id="probabilistic-strategy">Probabilistic Strategy<a class="anchor" aria-label="anchor" href="#probabilistic-strategy"></a>
</h3>
<p>When the interview date range spans exactly <strong>2
fortnights</strong> or <strong>2 weeks</strong>, the probabilistic
strategy calculates which period is more likely based on the position of
the date range boundaries.</p>
<p><strong>How it works:</strong></p>
<pre><code>For each undetermined observation with date range [date_min, date_max]:
  1. Check if range spans exactly 2 periods
  2. Calculate the midpoint: date_midpoint = (date_min + date_max) / 2
  3. Assign the period containing the midpoint
  4. Calculate confidence: based on distance from period boundary
     - Closer to boundary = lower confidence (~0.5)
     - Closer to edges = higher confidence (up to ~0.95)</code></pre>
<p><strong>Example:</strong></p>
<pre><code>Person with date range: March 10 - March 20 (within Q1 2023)
Fortnight boundary: March 15/16

Days in fortnight 5 (Mar 1-15):  10, 11, 12, 13, 14, 15 = 6 days
Days in fortnight 6 (Mar 16-31): 16, 17, 18, 19, 20     = 5 days

Date midpoint: March 15 -&gt; Falls in fortnight 5
Confidence: 6/11 ~ 0.55 (55% probability of fortnight 5)

Result: ref_fortnight_exp = 5, ref_fortnight_exp_confidence = 0.55</code></pre>
<p><strong>Confidence Score Distribution (from 2012-2025
benchmark):</strong></p>
<table class="table">
<thead><tr class="header">
<th>Range</th>
<th>N (Fortnight)</th>
<th>Percentage</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>(0.5, 0.6]</td>
<td>383,328</td>
<td>66.9%</td>
</tr>
<tr class="even">
<td>(0.6, 0.7]</td>
<td>165,280</td>
<td>28.8%</td>
</tr>
<tr class="odd">
<td>(0.7, 0.8]</td>
<td>22,506</td>
<td>3.9%</td>
</tr>
<tr class="even">
<td>(0.8, 0.9]</td>
<td>481</td>
<td>0.1%</td>
</tr>
<tr class="odd">
<td>(0.9, 1.0]</td>
<td>1,344</td>
<td>0.2%</td>
</tr>
</tbody>
</table>
<ul>
<li>
<strong>Mean confidence</strong>: 0.576</li>
<li>
<strong>Median confidence</strong>: 0.548</li>
<li>
<strong>Range</strong>: [0.516, 0.950]</li>
</ul>
<p>For weeks, all probabilistic assignments have confidence ~0.571
(fixed 2-week range).</p>
<p><strong>Interpretation</strong>: Most probabilistic assignments have
relatively low confidence (55-60%), meaning they’re only slightly better
than a coin flip. Use these assignments with caution and consider
filtering to higher confidence values (&gt;=0.7) for more reliable
analysis.</p>
<p><strong>Code example:</strong></p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Build standard crosswalk (store_date_bounds must be TRUE)</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>,</span>
<span>                                     store_date_bounds <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Apply probabilistic strategy with conservative threshold</span></span>
<span><span class="va">crosswalk_prob</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_experimental_periods.html">pnadc_experimental_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">crosswalk</span>,</span>
<span>  strategy <span class="op">=</span> <span class="st">"probabilistic"</span>,</span>
<span>  confidence_threshold <span class="op">=</span> <span class="fl">0.9</span>,</span>
<span>  upa_proportion_threshold <span class="op">=</span> <span class="fl">0.9</span>,  <span class="co"># Not used by probabilistic</span></span>
<span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Check results</span></span>
<span><span class="va">crosswalk_prob</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  strict_fortnight <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">determined_fortnight</span><span class="op">)</span>,</span>
<span>  experimental_fortnight <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_fortnight_exp</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  strict_week <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">determined_week</span><span class="op">)</span>,</span>
<span>  experimental_week <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_week_exp</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># Filter to high-confidence assignments (optional)</span></span>
<span><span class="va">high_conf_fortnights</span> <span class="op">&lt;-</span> <span class="va">crosswalk_prob</span><span class="op">[</span></span>
<span>  <span class="va">determined_fortnight</span> <span class="op">|</span> <span class="va">ref_fortnight_exp_confidence</span> <span class="op">&gt;=</span> <span class="fl">0.7</span></span>
<span><span class="op">]</span></span></code></pre></div>
<hr>
</div>
<div class="section level3">
<h3 id="upa-aggregation-strategy">UPA Aggregation Strategy<a class="anchor" aria-label="anchor" href="#upa-aggregation-strategy"></a>
</h3>
<blockquote>
<p><strong>Important Note:</strong> Despite theoretical appeal and the
remarkable 100% UPA homogeneity finding below, UPA aggregation provides
essentially <strong>zero improvement</strong> in determination rates in
comprehensive testing (2019-2020, 8 quarters, 3.76M observations).
Fortnight rate: 8.9% → 8.9%; Week rate: 3.3% → 3.3%. This section is
retained for methodological completeness, but users should rely on the
<strong>probabilistic strategy</strong> for practical improvements.</p>
</blockquote>
<p>The UPA aggregation strategy exploits a remarkable empirical finding:
<strong>100% UPA homogeneity</strong> for both fortnights and weeks.</p>
<blockquote>
<p><strong>Key Finding: 100% UPA Homogeneity</strong></p>
<p>Across 55 quarters of PNADC data (2012-2025, 9.6 million
household-quarter observations), we found that whenever a fortnight or
week IS strictly determined for any household in a UPA, ALL strictly
determined households in that UPA have the SAME fortnight/week. This
100% homogeneity rate provides strong empirical support for UPA-level
aggregation.</p>
</blockquote>
<p><strong>Why this works:</strong></p>
<p>IBGE’s interview scheduling creates natural clustering at the UPA
level. While IBGE does not officially state that entire UPAs are
interviewed on the same day, the empirical evidence strongly suggests
that interviews within a UPA are temporally clustered within narrow
windows.</p>
<p><strong>How it works:</strong></p>
<pre><code>For each (Ano, Trimestre, UPA):
  1. Find all households with strictly determined fortnight/week
  2. Check if all determined households have the SAME period
     (UPA proportion check - threshold default: 90%)
  3. If homogeneous: propagate that period to ALL households in the UPA
     (including those without strict determination)</code></pre>
<p><strong>UPA Aggregation Concept:</strong></p>
<pre><code>+---------------------------------------------------------------------+
|                    UPA = 123456 (Q1 2023)                            |
+---------------------------------------------------------------------+
|                                                                      |
|  Household A: fortnight = 3 (DETERMINED via birthday constraints)    |
|  Household B: fortnight = 3 (DETERMINED via birthday constraints)    |
|  Household C: fortnight = NA (undetermined)                          |
|  Household D: fortnight = NA (undetermined)                          |
|  Household E: fortnight = NA (undetermined)                          |
|                                                                      |
|  UPA Homogeneity Check:                                              |
|    - Determined households: A, B                                     |
|    - All have fortnight = 3? YES (100% homogeneous)                  |
|                                                                      |
|  Result: Propagate fortnight = 3 to C, D, E                          |
|    -&gt; ref_fortnight_exp = 3 for all 5 households                     |
|                                                                      |
+---------------------------------------------------------------------+</code></pre>
<p><strong>Theoretical vs Empirical Results:</strong></p>
<table class="table">
<thead><tr class="header">
<th>Metric</th>
<th>Fortnight</th>
<th>Week</th>
</tr></thead>
<tbody><tr class="odd">
<td>UPA Homogeneity Rate</td>
<td><strong>100.0%</strong></td>
<td><strong>100.0%</strong></td>
</tr></tbody>
</table>
<p><strong>Empirical Results (8-quarter comprehensive test, 2019-2020,
3.76M obs):</strong></p>
<table class="table">
<thead><tr class="header">
<th>Strategy</th>
<th>Fortnight Rate</th>
<th>Week Rate</th>
<th>Improvement</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Strict baseline</td>
<td>8.9%</td>
<td>3.3%</td>
<td>-</td>
</tr>
<tr class="even">
<td>UPA aggregation</td>
<td>8.9%</td>
<td>3.3%</td>
<td><strong>0 pp</strong></td>
</tr>
</tbody>
</table>
<p>While the homogeneity finding is real, it provides minimal practical
benefit because most UPAs already have all households determined (or all
undetermined) by the strict algorithm. The strategy cannot create
determinations where none exist - it can only propagate existing
determinations within UPAs, which is already rare.</p>
<p><strong>Code example:</strong></p>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Build standard crosswalk</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>,</span>
<span>                                     store_date_bounds <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Apply UPA aggregation strategy</span></span>
<span><span class="va">crosswalk_upa</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_experimental_periods.html">pnadc_experimental_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">crosswalk</span>,</span>
<span>  strategy <span class="op">=</span> <span class="st">"upa_aggregation"</span>,</span>
<span>  confidence_threshold <span class="op">=</span> <span class="fl">0.9</span>,  <span class="co"># Not used by UPA aggregation</span></span>
<span>  upa_proportion_threshold <span class="op">=</span> <span class="fl">0.9</span>,</span>
<span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Check UPA homogeneity and results</span></span>
<span><span class="co"># Output will show:</span></span>
<span><span class="co">#   UPA homogeneity (fortnight): 100.0%</span></span>
<span><span class="co">#   UPA homogeneity (week): 100.0%</span></span>
<span><span class="co">#   But minimal improvement in determination rates</span></span>
<span></span>
<span><span class="co"># Check improvement (will be minimal)</span></span>
<span><span class="va">crosswalk_upa</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  strict_only <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">determined_fortnight</span><span class="op">)</span>,</span>
<span>  with_exp <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">determined_fortnight</span> <span class="op">|</span> <span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_fortnight_exp</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  improvement <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_fortnight_exp</span><span class="op">)</span> <span class="op">&amp;</span> <span class="op">!</span><span class="va">determined_fortnight</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<hr>
</div>
<div class="section level3">
<h3 id="combined-strategy-both">Combined Strategy (“both”)<a class="anchor" aria-label="anchor" href="#combined-strategy-both"></a>
</h3>
<p>The combined strategy applies both probabilistic and UPA aggregation
<strong>sequentially</strong>:</p>
<ol style="list-style-type: decimal">
<li>
<strong>First, probabilistic strategy</strong> is applied</li>
<li>
<strong>Then, UPA aggregation</strong> is applied on top</li>
</ol>
<p>However, in comprehensive testing, the combined strategy produces the
<strong>same results as probabilistic alone</strong>:</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Apply both strategies</span></span>
<span><span class="va">crosswalk_both</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_experimental_periods.html">pnadc_experimental_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">crosswalk</span>,</span>
<span>  strategy <span class="op">=</span> <span class="st">"both"</span>,</span>
<span>  confidence_threshold <span class="op">=</span> <span class="fl">0.9</span>,</span>
<span>  upa_proportion_threshold <span class="op">=</span> <span class="fl">0.9</span>,</span>
<span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Results are identical to probabilistic alone</span></span>
<span><span class="va">crosswalk_both</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  strict_fortnight <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">determined_fortnight</span><span class="op">)</span>,</span>
<span>  experimental_fortnight <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_fortnight_exp</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  strict_week <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">determined_week</span><span class="op">)</span>,</span>
<span>  experimental_week <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_week_exp</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<p><strong>Combined Results (8-quarter comprehensive test):</strong></p>
<table class="table">
<thead><tr class="header">
<th>Metric</th>
<th>Strict</th>
<th>Probabilistic Only</th>
<th>Both Strategies</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Fortnight</td>
<td>8.9%</td>
<td>13.5%</td>
<td>13.5%</td>
</tr>
<tr class="even">
<td>Week (conf=0.9)</td>
<td>3.3%</td>
<td>3.6%</td>
<td>3.6%</td>
</tr>
<tr class="odd">
<td>Week (conf=0.8)</td>
<td>3.3%</td>
<td>7.5%</td>
<td>7.5%</td>
</tr>
</tbody>
</table>
<p><strong>Recommendation:</strong> Use
<code>strategy = "probabilistic"</code> rather than <code>"both"</code>
for simplicity - the results are identical.</p>
<hr>
</div>
<div class="section level3">
<h3 id="when-to-use-each-strategy">When to Use Each Strategy<a class="anchor" aria-label="anchor" href="#when-to-use-each-strategy"></a>
</h3>
<table class="table">
<colgroup>
<col width="31%">
<col width="44%">
<col width="23%">
</colgroup>
<thead><tr class="header">
<th>Analysis Type</th>
<th>Recommended Strategy</th>
<th>Rationale</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><strong>Publication-quality estimates</strong></td>
<td>Strict only</td>
<td>Definitive determinations, no assumptions</td>
</tr>
<tr class="even">
<td><strong>Moderate improvement needed</strong></td>
<td>Probabilistic (conf=0.9)</td>
<td>Conservative experimental assignments, 13.5% fortnight</td>
</tr>
<tr class="odd">
<td><strong>Maximum week coverage</strong></td>
<td>Probabilistic (conf=0.8)</td>
<td>Maximum week rate (7.5%), trade-off with confidence</td>
</tr>
<tr class="even">
<td><strong>Methodological research</strong></td>
<td>Compare strict vs probabilistic</td>
<td>Assess sensitivity to experimental assignments</td>
</tr>
</tbody>
</table>
<p><strong>Decision flowchart:</strong></p>
<pre><code>Need fortnight/week analysis?
|-- Strict sample (8.9% / 3.3%) sufficient?
|   +-- YES -&gt; Use pnadc_identify_periods() only
|   +-- NO  -&gt; Continue
|
|-- Need definitive determinations only?
|   +-- YES -&gt; Use strict (accept smaller sample)
|   +-- NO  -&gt; Continue
|
|-- Need weekly (vs fortnight) analysis?
|   +-- YES -&gt; Use probabilistic (conf=0.8) for max week rate (7.5%)
|   +-- NO  -&gt; Use probabilistic (conf=0.9) for conservative (13.5% fortnight)
|
+-- Maximum coverage needed?
    +-- YES -&gt; Use UPA aggregation or both
              (leverages 100% UPA homogeneity)</code></pre>
<hr>
</div>
<div class="section level3">
<h3 id="caveats-and-limitations">Caveats and Limitations<a class="anchor" aria-label="anchor" href="#caveats-and-limitations"></a>
</h3>
<ol style="list-style-type: decimal">
<li><p><strong>Probabilistic assignments are uncertain</strong>: Mean
confidence is ~0.58, meaning many assignments are only marginally better
than random. Consider filtering to confidence &gt;= 0.7 for
analysis.</p></li>
<li><p><strong>UPA aggregation assumes scheduling patterns
persist</strong>: The 100% homogeneity finding is based on 2012-2025
data. If IBGE changes interview scheduling, this assumption may
weaken.</p></li>
<li><p><strong>Neither replaces strict determination</strong>: For
rigorous causal analysis or official statistics, strict determination
should be preferred despite smaller sample sizes.</p></li>
<li><p><strong>Combine with caution</strong>: When using “both”
strategies, be aware that different households may have periods assigned
via different mechanisms (strict, probabilistic, or UPA). Use the
<code>probabilistic_assignment</code> flag to distinguish:
<code>FALSE</code> means strict determination, <code>TRUE</code> means
assigned via experimental methods.</p></li>
<li><p><strong>Validate for your specific use case</strong>: Run
sensitivity analysis comparing strict-only results with experimental
results to ensure conclusions are robust. Filter with
<code>crosswalk[probabilistic_assignment == FALSE]</code> to get
strict-only assignments.</p></li>
</ol>
<p><strong>Output columns from
<code><a href="../reference/pnadc_experimental_periods.html">pnadc_experimental_periods()</a></code>:</strong></p>
<table class="table">
<colgroup>
<col width="29%">
<col width="22%">
<col width="48%">
</colgroup>
<thead><tr class="header">
<th>Column</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>ref_month_exp</code></td>
<td>integer</td>
<td>Experimental month assignment (1-3 in quarter)</td>
</tr>
<tr class="even">
<td><code>ref_month_exp_confidence</code></td>
<td>numeric</td>
<td>Confidence score for month assignment (0-1)</td>
</tr>
<tr class="odd">
<td><code>ref_fortnight_exp</code></td>
<td>integer</td>
<td>Experimental fortnight assignment (1-6 in quarter)</td>
</tr>
<tr class="even">
<td><code>ref_fortnight_exp_confidence</code></td>
<td>numeric</td>
<td>Confidence score for fortnight assignment (0-1)</td>
</tr>
<tr class="odd">
<td><code>ref_week_exp</code></td>
<td>integer</td>
<td>Experimental week assignment (1-12 in quarter)</td>
</tr>
<tr class="even">
<td><code>ref_week_exp_confidence</code></td>
<td>numeric</td>
<td>Confidence score for week assignment (0-1)</td>
</tr>
<tr class="odd">
<td><code>probabilistic_assignment</code></td>
<td>logical</td>
<td>TRUE if assigned via experimental method (vs strict)</td>
</tr>
</tbody>
</table>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="weight-calibration">Weight Calibration<a class="anchor" aria-label="anchor" href="#weight-calibration"></a>
</h2>
<p>For sub-quarterly aggregate estimates, you need appropriately
calibrated survey weights. The package supports calibration for all
three period types: monthly, fortnightly, and weekly.</p>
<div class="section level3">
<h3 id="how-calibration-works-general-principles">How Calibration Works (General Principles)<a class="anchor" aria-label="anchor" href="#how-calibration-works-general-principles"></a>
</h3>
<p>When <code>calibrate = TRUE</code> in
<code><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods()</a></code>, the package:</p>
<p><strong>1. Fetches monthly population from SIDRA API</strong> (table
6022)</p>
<p>SIDRA provides <strong>moving-quarter</strong> population estimates,
not exact monthly values:</p>
<table class="table">
<thead><tr class="header">
<th>SIDRA Code</th>
<th>3-Month Window</th>
<th>Represents Population For</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>201203</td>
<td>Jan+Feb+Mar 2012</td>
<td><strong>February 2012</strong></td>
</tr>
<tr class="even">
<td>201204</td>
<td>Feb+Mar+Apr 2012</td>
<td><strong>March 2012</strong></td>
</tr>
<tr class="odd">
<td>201205</td>
<td>Mar+Apr+May 2012</td>
<td><strong>April 2012</strong></td>
</tr>
</tbody>
</table>
<p>The package shifts values to align with their center month. Boundary
months (Jan 2012, latest month) are extrapolated via quadratic
regression.</p>
<p><strong>2. Applies hierarchical rake weighting</strong> across nested
calibration cells:</p>
<table class="table">
<colgroup>
<col width="36%">
<col width="36%">
<col width="27%">
</colgroup>
<thead><tr class="header">
<th>Cell Level</th>
<th>Definition</th>
<th>Purpose</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>celula1</code></td>
<td>Age groups: 0-13, 14-29, 30-59, 60+</td>
<td>Demographic balance</td>
</tr>
<tr class="even">
<td><code>celula2</code></td>
<td>Post-stratum group + age</td>
<td>Regional-demographic balance</td>
</tr>
<tr class="odd">
<td><code>celula3</code></td>
<td>State (UF) + celula2</td>
<td>State-level balance</td>
</tr>
<tr class="even">
<td><code>celula4</code></td>
<td>Post-stratum (posest) + celula2</td>
<td>Fine geographic balance</td>
</tr>
</tbody>
</table>
<p>The number of cell levels used depends on the calibration unit (see
“Fortnight and Weekly Calibration” below). At each level, weights are
adjusted so period totals match anchor totals proportionally.</p>
<p><strong>3. Calibrates to monthly population totals</strong></p>
<p>Final scaling ensures monthly weighted totals match SIDRA population
(~206 million average).</p>
</div>
<div class="section level3">
<h3 id="monthly-calibration">Monthly Calibration<a class="anchor" aria-label="anchor" href="#monthly-calibration"></a>
</h3>
<p>Monthly calibration uses the full 4-level hierarchical raking because
the high determination rate (~97%) provides sufficient sample size in
each cell.</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Apply crosswalk and calibrate monthly weights</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>, <span class="va">crosswalk</span>,</span>
<span>                               weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>                               anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>                               calibration_unit <span class="op">=</span> <span class="st">"month"</span>,  <span class="co"># default</span></span>
<span>                               calibrate <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Use weight_monthly for monthly estimates</span></span>
<span><span class="va">monthly_pop</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  population <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_monthly</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="va">ref_month_yyyymm</span><span class="op">]</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="fortnight-and-week-calibration">Fortnight and Week Calibration<a class="anchor" aria-label="anchor" href="#fortnight-and-week-calibration"></a>
</h3>
<p>The package also supports calibrating weights for fortnight and
weekly analysis using <code>calibration_unit = "fortnight"</code> or
<code>calibration_unit = "week"</code>.</p>
<p><strong>Population Targets</strong></p>
<p>All time periods are calibrated to the <strong>full Brazilian
population</strong> from SIDRA:</p>
<table class="table">
<thead><tr class="header">
<th>Calibration Unit</th>
<th>Population Target</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Month</td>
<td>SIDRA monthly population (~206 million)</td>
</tr>
<tr class="even">
<td>Fortnight</td>
<td>Full monthly population of the containing month</td>
</tr>
<tr class="odd">
<td>Week</td>
<td>Full monthly population of the containing month</td>
</tr>
</tbody>
</table>
<p>This means that if you sum <code>weight_fortnight</code> for a given
fortnight, or <code>weight_weekly</code> for a given week, you get the
total Brazilian population for that period (not a fraction of it).</p>
<p><strong>Simplified Hierarchical Raking</strong></p>
<p>Because fortnights and weeks have much lower determination rates
(8.9% and 3.3% respectively), the hierarchical raking is automatically
simplified to avoid sparse cell issues:</p>
<table class="table">
<colgroup>
<col width="31%">
<col width="18%">
<col width="31%">
<col width="18%">
</colgroup>
<thead><tr class="header">
<th>Calibration Unit</th>
<th>Det. Rate</th>
<th>Cell Levels Used</th>
<th>Rationale</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Month</td>
<td>94-97%</td>
<td>4 levels (celula1-4)</td>
<td>~65,000+ obs/period allows fine cells</td>
</tr>
<tr class="even">
<td>Fortnight</td>
<td>8.9%</td>
<td>2 levels (celula1-2)</td>
<td>~5,000 obs/period; finer cells too sparse</td>
</tr>
<tr class="odd">
<td>Week</td>
<td>3.3%</td>
<td>1 level (celula1 only)</td>
<td>~500 obs/period; only age groups stable</td>
</tr>
</tbody>
</table>
<p>The algorithm also checks minimum cell sizes (default: 10
observations) and skips raking levels if cells become too sparse.</p>
<p><strong>Smoothing Behavior</strong></p>
<p>Smoothing to remove quarterly artifacts is also adapted:</p>
<table class="table">
<thead><tr class="header">
<th>Calibration Unit</th>
<th>Smoothing Window</th>
<th>Cell Level</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Month</td>
<td>3-period rolling mean</td>
<td>celula4</td>
</tr>
<tr class="even">
<td>Fortnight</td>
<td>7-period rolling mean</td>
<td>celula2</td>
</tr>
<tr class="odd">
<td>Week</td>
<td>No smoothing</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<p>Weekly data skips smoothing entirely because the small sample sizes
make cell-level smoothing unstable.</p>
<p><strong>Usage Example</strong></p>
<div class="sourceCode" id="cb32"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Fortnight calibration</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span><span class="va">pnadc_data</span>, <span class="va">crosswalk</span>,</span>
<span>                               weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>                               anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>                               calibration_unit <span class="op">=</span> <span class="st">"fortnight"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Weekly calibration</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span><span class="va">pnadc_data</span>, <span class="va">crosswalk</span>,</span>
<span>                               weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>                               anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>                               calibration_unit <span class="op">=</span> <span class="st">"week"</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="handling-indeterminate-observations">Handling Indeterminate Observations<a class="anchor" aria-label="anchor" href="#handling-indeterminate-observations"></a>
</h3>
<p>By default (<code>keep_all = TRUE</code>), all input rows are
returned, with <code>weight_monthly = NA</code> for indeterminate
observations:</p>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Build crosswalk and apply (returns all rows by default)</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">pnadc_full</span><span class="op">)</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span><span class="va">pnadc_full</span>, <span class="va">crosswalk</span>,</span>
<span>                               weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>                               anchor <span class="op">=</span> <span class="st">"quarter"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">result</span><span class="op">)</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">pnadc_full</span><span class="op">)</span>  <span class="co"># TRUE - all rows returned</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">result</span><span class="op">$</span><span class="va">weight_monthly</span><span class="op">)</span><span class="op">)</span>  <span class="co"># ~3% of rows have NA weights</span></span>
<span></span>
<span><span class="co"># Use na.rm = TRUE when aggregating</span></span>
<span><span class="va">monthly_pop</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span>pop <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_monthly</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>, by <span class="op">=</span> <span class="va">ref_month_yyyymm</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># Filter to determined rows for analysis</span></span>
<span><span class="va">result_determined</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">result_determined</span><span class="op">)</span> <span class="op">&lt;</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">pnadc_full</span><span class="op">)</span>  <span class="co"># TRUE (~97% of rows)</span></span></code></pre></div>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="weight-smoothing">Weight Smoothing<a class="anchor" aria-label="anchor" href="#weight-smoothing"></a>
</h2>
<p>During weight calibration, the package can optionally apply smoothing
to reduce artificial quarterly patterns in the calibrated weights. This
is controlled by the <code>smooth</code> parameter in
<code><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods()</a></code> (default: <code>TRUE</code>).</p>
<div class="section level3">
<h3 id="why-weight-smoothing-helps">Why Weight Smoothing Helps<a class="anchor" aria-label="anchor" href="#why-weight-smoothing-helps"></a>
</h3>
<p>PNADC’s quarterly structure creates subtle artifacts in monthly
estimates:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Rotation group composition varies by month</strong>: Each
quarter has 5 rotation groups, but their distribution across months
isn’t perfectly even. Some months may have slightly more observations
from groups with different demographic compositions.</p></li>
<li><p><strong>Boundary effects</strong>: The first and last months of a
quarter can have different characteristics than middle months due to how
interviews are scheduled around “Parada Tecnica” (technical
breaks).</p></li>
<li><p><strong>Cell-level imbalances</strong>: Within demographic cells
(age x region x stratum), the month-to-month sample sizes can vary,
creating artificial jumps even when the true population is
stable.</p></li>
</ol>
<p>Weight smoothing addresses these issues by applying a rolling mean to
the calibration adjustments at the cell level, reducing artificial
volatility while preserving genuine trends.</p>
</div>
<div class="section level3">
<h3 id="how-weight-smoothing-works">How Weight Smoothing Works<a class="anchor" aria-label="anchor" href="#how-weight-smoothing-works"></a>
</h3>
<p>During calibration, the package applies rolling mean smoothing to
cell-level population ratios:</p>
<pre><code>For each (cell, period):
  1. Calculate cell population: pop_cell_period = sum(weights)
  2. Apply rolling mean across periods within cell:
     pop_smoothed = frollmean(pop_cell_period, window, align="center")
  3. Calculate smoothing factor: factor = pop_smoothed / pop_cell_period
  4. Adjust individual weights: weight_new = weight_old * factor</code></pre>
<p>The smoothing window adapts by time period granularity:</p>
<table class="table">
<thead><tr class="header">
<th>Period</th>
<th>Window</th>
<th>Rationale</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Month</td>
<td>3 periods</td>
<td>Captures quarter-to-quarter transitions</td>
</tr>
<tr class="even">
<td>Fortnight</td>
<td>7 periods</td>
<td>Wider window for more volatile estimates</td>
</tr>
<tr class="odd">
<td>Week</td>
<td>None</td>
<td>Sample too small for stable smoothing</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="when-to-disable-smoothing">When to Disable Smoothing<a class="anchor" aria-label="anchor" href="#when-to-disable-smoothing"></a>
</h3>
<p>By default, <code>smooth = TRUE</code> is recommended for most
analyses. However, you may want to disable smoothing
(<code>smooth = FALSE</code>) in certain situations:</p>
<p><strong>Disable smoothing when:</strong></p>
<ul>
<li><p><strong>Analyzing rapid shocks</strong>: When studying events
with genuine month-to-month discontinuities (e.g., COVID-19 lockdown
effects in March 2020, sudden policy changes), smoothing may blur the
true timing of the effect.</p></li>
<li><p><strong>Studying short-term dynamics</strong>: When the research
question focuses on immediate month-to-month changes rather than
trends.</p></li>
<li><p><strong>Comparing specific months</strong>: When comparing the
same month across different years (e.g., December 2022 vs December
2023), smoothing may introduce bias from adjacent months.</p></li>
</ul>
<p><strong>Keep smoothing enabled when:</strong></p>
<ul>
<li>Computing time series for publication or visualization</li>
<li>Analyzing gradual trends (employment growth, demographic
shifts)</li>
<li>The underlying phenomenon is expected to change smoothly over
time</li>
</ul>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># With smoothing (default) - recommended for most analyses</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_data</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  smooth <span class="op">=</span> <span class="cn">TRUE</span>  <span class="co"># default</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Without smoothing - for shock analysis</span></span>
<span><span class="va">result_unsmoothed</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_data</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  smooth <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><strong>Note</strong>: Smoothing is applied to the microdata weights
during calibration. If you still observe quarterly artifacts in your
final aggregated estimates, this may indicate genuine sampling variation
rather than calibration artifacts.</p>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="applying-the-crosswalk">Applying the Crosswalk<a class="anchor" aria-label="anchor" href="#applying-the-crosswalk"></a>
</h2>
<p>The package uses a <strong>two-step workflow</strong> to convert
PNADC data into sub-quarterly time series:</p>
<ol style="list-style-type: decimal">
<li>
<strong><code><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods()</a></code></strong>: Build a
crosswalk that identifies reference periods (months, fortnights, weeks)
for each household-quarter observation</li>
<li>
<strong><code><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods()</a></code></strong>: Merge this
crosswalk with your PNADC data and optionally calibrate weights</li>
</ol>
<p>This separation is deliberate: the crosswalk is built once from
stacked quarterly data (which contains birthday variables), then applied
to either quarterly or annual datasets for analysis.</p>
<div class="section level3">
<h3 id="the-two-step-workflow">The Two-Step Workflow<a class="anchor" aria-label="anchor" href="#the-two-step-workflow"></a>
</h3>
<pre><code>+-----------------------------------------------------------------------------+
|                        TWO-STEP WORKFLOW                                     |
+-----------------------------------------------------------------------------+

STEP 1: Build Crosswalk (run once, from quarterly data)
+-----------------------------------------------------------------------+
| pnadc_identify_periods(quarterly_stacked)                              |
|                                                                        |
| Input:  Stacked quarterly PNADC (needs birthday variables)             |
| Output: Crosswalk with ref_month, ref_fortnight, ref_week per          |
|         (UPA, V1014) household-panel group                             |
+-----------------------------------------------------------------------+
                                    |
                                    v
STEP 2: Apply to Target Data (run for each analysis)
+-----------------------------------------------------------------------+
| pnadc_apply_periods(target_data, crosswalk, ...)                       |
|                                                                        |
| Input:  Any PNADC data (quarterly OR annual) + crosswalk               |
| Output: Data with reference periods + calibrated weights               |
|                                                                        |
| Key parameters:                                                        |
|   - weight_var: "V1028" (quarterly) or "V1032" (annual)                |
|   - anchor: "quarter" (quarterly) or "year" (annual)                   |
|   - calibration_unit: "month", "fortnight", or "week"                  |
+-----------------------------------------------------------------------+</code></pre>
</div>
<div class="section level3">
<h3 id="quarterly-vs--annual-pnadc-data">Quarterly vs. Annual PNADC Data<a class="anchor" aria-label="anchor" href="#quarterly-vs--annual-pnadc-data"></a>
</h3>
<p>PNADC has two main data releases that require different
approaches:</p>
<table class="table">
<colgroup>
<col width="22%">
<col width="41%">
<col width="36%">
</colgroup>
<thead><tr class="header">
<th>Aspect</th>
<th>Quarterly Data</th>
<th>Annual Data</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><strong>Primary focus</strong></td>
<td>Labor market (employment, unemployment)</td>
<td>Income and poverty</td>
</tr>
<tr class="even">
<td><strong>Key income variable</strong></td>
<td>Limited (labor income only)</td>
<td>VD5008 (comprehensive household income)</td>
</tr>
<tr class="odd">
<td><strong>Weight variable</strong></td>
<td>V1028 (quarterly weight)</td>
<td>V1032 (annual/visit-specific weight)</td>
</tr>
<tr class="even">
<td><strong>Panel coverage</strong></td>
<td>All 5 rotation groups mixed</td>
<td>One specific visit (e.g., visit 1 or visit 5)</td>
</tr>
<tr class="odd">
<td><strong>Monthly observations</strong></td>
<td>~20% from each visit</td>
<td>100% from single visit</td>
</tr>
<tr class="even">
<td><strong>Function call</strong></td>
<td><code>anchor = "quarter"</code></td>
<td><code>anchor = "year"</code></td>
</tr>
</tbody>
</table>
<p><strong>Key insight</strong>: Reference period identification works
identically for both data types (birthday constraints don’t depend on
weight variables). The difference is in <strong>weight
calibration</strong>: quarterly weights distribute quarterly totals
across 3 months, while annual weights distribute yearly totals across 12
months.</p>
</div>
<div class="section level3">
<h3 id="applying-to-quarterly-data">Applying to Quarterly Data<a class="anchor" aria-label="anchor" href="#applying-to-quarterly-data"></a>
</h3>
<p>Use <code>anchor = "quarter"</code> with quarterly PNADC data (V1028
weights):</p>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Build crosswalk from stacked quarterly data</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">pnadc_stacked</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Apply to quarterly data with monthly weights</span></span>
<span><span class="va">result_monthly</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_quarterly</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"month"</span>,</span>
<span>  calibrate <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Apply with fortnight weights (for short-term analysis)</span></span>
<span><span class="va">result_fortnight</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_quarterly</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"fortnight"</span>,</span>
<span>  calibrate <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Apply with weekly weights (for high-frequency monitoring)</span></span>
<span><span class="va">result_weekly</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_quarterly</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"week"</span>,</span>
<span>  calibrate <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="applying-to-annual-data">Applying to Annual Data<a class="anchor" aria-label="anchor" href="#applying-to-annual-data"></a>
</h3>
<p>Use <code>anchor = "year"</code> with annual PNADC data (V1032
weights). Note that <strong>the crosswalk is still built from quarterly
data</strong> (which contains the birthday variables needed for period
identification).</p>
<div class="sourceCode" id="cb38"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Step 1: Build crosswalk from quarterly data</span></span>
<span><span class="va">quarterly_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="http://www.fstpackage.org/reference/write_fst.html" class="external-link">read_fst</a></span><span class="op">(</span><span class="st">"pnadc_quarterly_stacked.fst"</span>, as.data.table <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">quarterly_data</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Step 2: Load annual data with income variables</span></span>
<span><span class="va">annual_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="http://www.fstpackage.org/reference/write_fst.html" class="external-link">read_fst</a></span><span class="op">(</span><span class="st">"pnadc_2023_visita1.fst"</span>, as.data.table <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Step 3: Apply crosswalk with annual calibration</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">annual_data</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1032"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"year"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"month"</span>,</span>
<span>  calibrate <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Use for monthly income/poverty analysis</span></span>
<span><span class="va">monthly_income</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  mean_income <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/weighted.mean.html" class="external-link">weighted.mean</a></span><span class="op">(</span><span class="va">VD5008</span>, <span class="va">weight_monthly</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="va">ref_month_yyyymm</span><span class="op">]</span></span></code></pre></div>
<p>Annual data can also be calibrated at fortnight or week level by
changing <code>calibration_unit</code>.</p>
</div>
<div class="section level3">
<h3 id="covid-era-visit-selection">COVID-Era Visit Selection<a class="anchor" aria-label="anchor" href="#covid-era-visit-selection"></a>
</h3>
<p>For annual data, you must choose which panel visit to use. During
COVID-19 (2020-2021), visit 1 was often unavailable:</p>
<table class="table">
<thead><tr class="header">
<th>Period</th>
<th>Recommended Visit</th>
<th>Reason</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>2015-2019</td>
<td>Visit 1</td>
<td>Standard practice</td>
</tr>
<tr class="even">
<td>2020-2021</td>
<td>Visit 5</td>
<td>COVID-era data collection issues</td>
</tr>
<tr class="odd">
<td>2022-2024</td>
<td>Visit 1</td>
<td>Post-pandemic normalization</td>
</tr>
</tbody>
</table>
<p>For a complete example of poverty analysis with annual data, see the
<a href="annual-poverty-analysis.html">Annual Poverty Analysis</a>
vignette.</p>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="advanced-usage">Advanced Usage<a class="anchor" aria-label="anchor" href="#advanced-usage"></a>
</h2>
<div class="section level3">
<h3 id="using-modular-functions">Using Modular Functions<a class="anchor" aria-label="anchor" href="#using-modular-functions"></a>
</h3>
<p>For more control, use the individual identification functions:</p>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Identify reference months only</span></span>
<span><span class="va">months</span> <span class="op">&lt;-</span> <span class="fu">identify_reference_month</span><span class="op">(</span><span class="va">pnadc_stacked</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Identify fortnights only</span></span>
<span><span class="va">fortnights</span> <span class="op">&lt;-</span> <span class="fu">identify_reference_fortnight</span><span class="op">(</span><span class="va">pnadc_stacked</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Identify weeks only</span></span>
<span><span class="va">weeks</span> <span class="op">&lt;-</span> <span class="fu">identify_reference_week</span><span class="op">(</span><span class="va">pnadc_stacked</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Check determination rates by quarter</span></span>
<span><span class="va">months</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  total <span class="op">=</span> <span class="va">.N</span>,</span>
<span>  determined <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  rate <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span><span class="op">)</span> <span class="op">*</span> <span class="fl">100</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">Ano</span>, <span class="va">Trimestre</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<p>Output (sample from 2023, using real PNADC data):</p>
<pre><code>   Ano Trimestre  total determined  rate
 &lt;int&gt;     &lt;int&gt;  &lt;int&gt;      &lt;int&gt; &lt;num&gt;
1: 2023         1 169879     162107  95.4
2: 2023         2 171776     164920  96.0
3: 2023         3 175418     169215  96.5
4: 2023         4 173676     168094  96.8</code></pre>
</div>
<div class="section level3">
<h3 id="validation-and-population-data">Validation and Population Data<a class="anchor" aria-label="anchor" href="#validation-and-population-data"></a>
</h3>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Validate input data before processing</span></span>
<span><span class="va">validation</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/validate_pnadc.html">validate_pnadc</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>, stop_on_error <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Fetch population data from SIDRA-IBGE manually (for inspection)</span></span>
<span><span class="va">pop_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fetch_monthly_population.html">fetch_monthly_population</a></span><span class="op">(</span>verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">pop_data</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Note: pnadc_apply_periods() fetches population data automatically</span></span>
<span><span class="co"># when calibrate = TRUE. Manual fetching is only needed for inspection</span></span>
<span><span class="co"># or custom calibration workflows.</span></span></code></pre></div>
<p>Output (sample from fetch_monthly_population):</p>
<pre><code>Fetching monthly population data from SIDRA (table 6022)...
  Retrieved 159 rows for 2012-2025

   year_month population_total
        &lt;int&gt;            &lt;num&gt;
1:     201202        193146000
2:     201203        193470000
3:     201204        193804000
4:     201205        194138000
5:     201206        194469000
6:     201207        194788000</code></pre>
</div>
<div class="section level3">
<h3 id="experimental-period-strategies">Experimental Period Strategies<a class="anchor" aria-label="anchor" href="#experimental-period-strategies"></a>
</h3>
<p>For improved fortnight/week determination, use the experimental
strategies:</p>
<div class="sourceCode" id="cb43"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Build standard crosswalk first (store_date_bounds required for experimental)</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>, store_date_bounds <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Apply experimental strategies for improved fortnight/week determination</span></span>
<span><span class="va">crosswalk_exp</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_experimental_periods.html">pnadc_experimental_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">crosswalk</span>,</span>
<span>  strategy <span class="op">=</span> <span class="st">"probabilistic"</span>,  <span class="co"># Options: "probabilistic", "upa_aggregation", "both"</span></span>
<span>  confidence_threshold <span class="op">=</span> <span class="fl">0.9</span>,</span>
<span>  upa_proportion_threshold <span class="op">=</span> <span class="fl">0.9</span>,</span>
<span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Check improvement</span></span>
<span><span class="va">crosswalk_exp</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  strict_fortnight <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">determined_fortnight</span><span class="op">)</span>,</span>
<span>  experimental_fortnight <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_fortnight_exp</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  strict_week <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">determined_week</span><span class="op">)</span>,</span>
<span>  experimental_week <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_week_exp</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<p>Output:</p>
<pre><code>Applying probabilistic strategy...
  Calculating date bounds for probabilistic assignment...
  Calculating probabilistic assignments for narrow ranges...
  Probabilistic fortnight: 572,939 assignments (6.5% of undetermined)
  Probabilistic week: 26,878 assignments (0.3% of undetermined)
Applying UPA aggregation strategy...
  Calculating UPA homogeneity rate...
  UPA homogeneity (fortnight): 100.0%
  UPA proportion 100.0% &gt;= threshold 90.0%. Applying UPA aggregation.
  UPA-aggregated fortnight: 4,803,577 additional assignments (54.2% of undetermined)
  UPA homogeneity (week): 100.0%

   strict_fortnight with_prob  with_upa    total
              &lt;num&gt;     &lt;num&gt;     &lt;num&gt;    &lt;num&gt;
1:           0.0764    0.1361    0.5769   0.6033</code></pre>
<p>See the <a href="#experimental-strategies">Experimental
Strategies</a> section for detailed documentation.</p>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="performance">Performance<a class="anchor" aria-label="anchor" href="#performance"></a>
</h2>
<div class="section level3">
<h3 id="benchmarks">Benchmarks<a class="anchor" aria-label="anchor" href="#benchmarks"></a>
</h3>
<p><strong>Period Identification
(<code><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods()</a></code>):</strong></p>
<table class="table">
<thead><tr class="header">
<th>Dataset Size</th>
<th>Rows</th>
<th>Time</th>
<th>Throughput</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>1 quarter</td>
<td>~570K</td>
<td>~1.5 sec</td>
<td>~380K rows/sec</td>
</tr>
<tr class="even">
<td>1 year</td>
<td>~2.3M</td>
<td>~5 sec</td>
<td>~460K rows/sec</td>
</tr>
<tr class="odd">
<td>14 years (2012-2025)</td>
<td>28.4M</td>
<td><strong>~2.5 minutes</strong></td>
<td>~177K rows/sec</td>
</tr>
</tbody>
</table>
<p><strong>Key optimization</strong>: The <code><a href="https://lubridate.tidyverse.org/reference/make_datetime.html" class="external-link">make_date()</a></code>
function uses pre-computed lookup tables instead of
<code><a href="https://rdrr.io/r/base/ISOdatetime.html" class="external-link">ISOdate()</a></code>, achieving <strong>20x speedup</strong> on date
operations.</p>
<p><strong>Experimental Strategies
(<code><a href="../reference/pnadc_experimental_periods.html">pnadc_experimental_periods()</a></code>):</strong></p>
<table class="table">
<thead><tr class="header">
<th>Strategy</th>
<th>Execution Time</th>
<th>Notes</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>probabilistic</td>
<td>~220 seconds</td>
<td>Requires recalculating date bounds</td>
</tr>
<tr class="even">
<td>upa_aggregation</td>
<td>~15 seconds</td>
<td>Fast aggregation only</td>
</tr>
<tr class="odd">
<td>both</td>
<td>~235 seconds</td>
<td>Sequential application</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="determination-rates-by-period">Determination Rates by Period<a class="anchor" aria-label="anchor" href="#determination-rates-by-period"></a>
</h3>
<p>Based on real PNADC data (2012-2025, 55 quarters, 28.4M observations,
9.6M household-quarters):</p>
<p><strong>Overall rates (strict determination):</strong></p>
<table class="table">
<thead><tr class="header">
<th>Period</th>
<th>Determined</th>
<th>Total</th>
<th>Rate</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Month</td>
<td>9,281,135</td>
<td>9,598,723</td>
<td>
<strong>97%</strong> (55Q), <strong>94%</strong> (8Q)</td>
</tr>
<tr class="even">
<td>Fortnight</td>
<td>733,744</td>
<td>9,598,723</td>
<td>
<strong>8.9%</strong> (8Q), <strong>9.2%</strong> (55Q)</td>
</tr>
<tr class="odd">
<td>Week</td>
<td>147,692</td>
<td>9,598,723</td>
<td>
<strong>3.3%</strong> (all levels)</td>
</tr>
</tbody>
</table>
<p><strong>Rates by year (monthly):</strong></p>
<table class="table">
<thead><tr class="header">
<th>Year</th>
<th>N</th>
<th>Monthly Rate</th>
<th>Fortnight Rate</th>
<th>Week Rate</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>2012</td>
<td>695K</td>
<td>96.3%</td>
<td>8.5%</td>
<td>1.7%</td>
</tr>
<tr class="even">
<td>2013-2019</td>
<td>5.2M</td>
<td>97-99%</td>
<td>~9%</td>
<td>~3%</td>
</tr>
<tr class="odd">
<td>2020-2021</td>
<td>1.1M</td>
<td>93-96%</td>
<td>~9%</td>
<td>~3%</td>
</tr>
<tr class="even">
<td>2022-2024</td>
<td>2.1M</td>
<td>95-97%</td>
<td>~9%</td>
<td>~3%</td>
</tr>
<tr class="odd">
<td>2025</td>
<td>541K</td>
<td>93%</td>
<td>~9%</td>
<td>~3%</td>
</tr>
</tbody>
</table>
<p><strong>With experimental strategies (8-quarter
benchmark):</strong></p>
<table class="table">
<thead><tr class="header">
<th>Strategy</th>
<th>Fortnight</th>
<th>Week</th>
<th>Notes</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Strict only</td>
<td>8.9%</td>
<td>3.3%</td>
<td>Definitive determinations</td>
</tr>
<tr class="even">
<td>+ Probabilistic (0.9)</td>
<td><strong>13.5%</strong></td>
<td>3.6%</td>
<td>Conservative threshold</td>
</tr>
<tr class="odd">
<td>+ Probabilistic (0.8)</td>
<td>13.5%</td>
<td><strong>7.5%</strong></td>
<td>Maximum week coverage</td>
</tr>
<tr class="even">
<td>+ UPA Aggregation</td>
<td>8.9%</td>
<td>3.3%</td>
<td>No practical improvement</td>
</tr>
<tr class="odd">
<td>+ Both (0.9)</td>
<td>13.5%</td>
<td>3.6%</td>
<td>Same as probabilistic</td>
</tr>
</tbody>
</table>
<p><strong>Interpretation:</strong> Probabilistic strategy is the only
effective experimental method. Choose confidence threshold based on
needs: - <strong>0.9</strong>: Conservative, minimal week improvement -
<strong>0.8</strong>: Maximum week rate (7.5%), trade-off with
confidence</p>
<p><strong>Why boundary quarters have lower rates</strong>: The first 4
and last 4 quarters of any consecutive quarterly dataset will always
include (UPA, V1014) groups with fewer than 5 visits in the data. This
makes mensalization efficiency suboptimal at the boundaries. In a
dataset with 9 consecutive quarters, for example, only the 5th quarter
will have full utilization - because among people observed in the 5th
quarter, all of them will have all their visits in the data, from those
on their 1st visit in the 5th quarter to those on their 5th visit in the
5th quarter. This is an inherent consequence of PNADC’s rotating panel
design (5 visits over 5 quarters).</p>
</div>
<div class="section level3">
<h3 id="optimization-tips">Optimization Tips<a class="anchor" aria-label="anchor" href="#optimization-tips"></a>
</h3>
<ul>
<li>Use <code>data.table</code> directly (automatic conversion from
<code>data.frame</code> adds overhead)</li>
<li>Load only required columns when reading data</li>
<li>Process multiple years together (cross-quarter aggregation improves
accuracy)</li>
</ul>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="tips-and-best-practices">Tips and Best Practices<a class="anchor" aria-label="anchor" href="#tips-and-best-practices"></a>
</h2>
<ol style="list-style-type: decimal">
<li><p><strong>Process multiple quarters together</strong>: Processing
2012-2025 together gives ~97% determination vs ~73% for a single
quarter.</p></li>
<li><p><strong>Start with reference month identification</strong>: You
don’t always need monthly weights. Often just knowing the reference
month is enough.</p></li>
<li>
<p><strong>Check determination rates by year</strong>: Monthly rates
should be 97-99% for 2013-2019. Lower rates may indicate data
issues.</p>
<div class="sourceCode" id="cb45"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">crosswalk</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span>rate <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">Ano</span>, <span class="va">Trimestre</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<p>Example output (2019):</p>
<pre><code>   Ano Trimestre   rate
 &lt;int&gt;     &lt;int&gt;  &lt;num&gt;
1: 2019         1 0.973
2: 2019         2 0.976
3: 2019         3 0.979
4: 2019         4 0.978</code></pre>
</li>
<li><p><strong>Handle indeterminate observations</strong>: Decide
whether to exclude them or use quarterly-level analysis for those
cases.</p></li>
<li><p><strong>Use <code>weight_monthly</code> for general
analysis</strong>: The rake-weighted output is appropriate for most
purposes.</p></li>
<li><p><strong>Consider experimental strategies for
fortnights/weeks</strong>: If you need larger fortnight/week samples,
use <code><a href="../reference/pnadc_experimental_periods.html">pnadc_experimental_periods()</a></code> with probabilistic
strategy to achieve 13.5% fortnight determination and up to 7.5% week
determination (with conf=0.8). See <a href="#experimental-strategies">Experimental Strategies</a>.</p></li>
</ol>
<hr>
</div>
<div class="section level2">
<h2 id="complete-workflow-example">Complete Workflow Example<a class="anchor" aria-label="anchor" href="#complete-workflow-example"></a>
</h2>
<p>This section demonstrates the complete workflow from raw PNADC data
to monthly time series, incorporating all the concepts from this
vignette.</p>
<div class="section level3">
<h3 id="scenario-monthly-unemployment-analysis-2019-2024">Scenario: Monthly Unemployment Analysis (2019-2024)<a class="anchor" aria-label="anchor" href="#scenario-monthly-unemployment-analysis-2019-2024"></a>
</h3>
<div class="sourceCode" id="cb47"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://antrologos.github.io/PNADCperiods/">PNADCperiods</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-datatable.com" class="external-link">data.table</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 1: Load and stack quarterly PNADC data</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="co"># Load quarterly data (recommend 2+ years for good determination rates)</span></span>
<span><span class="co"># Real data should be loaded from your files, e.g.:</span></span>
<span><span class="co"># files &lt;- list.files("path/to/data", pattern = "pnadc_.*\\.fst$", full.names = TRUE)</span></span>
<span><span class="co"># pnadc_stacked &lt;- rbindlist(lapply(files, fst::read_fst, as.data.table = TRUE))</span></span>
<span></span>
<span><span class="co"># Required columns for identification:</span></span>
<span><span class="va">required_id</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Ano"</span>, <span class="st">"Trimestre"</span>, <span class="st">"UPA"</span>, <span class="st">"V1008"</span>, <span class="st">"V1014"</span>,</span>
<span>                 <span class="st">"V2003"</span>, <span class="st">"V2008"</span>, <span class="st">"V20081"</span>, <span class="st">"V20082"</span>, <span class="st">"V2009"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Additional columns for calibration:</span></span>
<span><span class="va">required_weights</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"V1028"</span>, <span class="st">"UF"</span>, <span class="st">"posest"</span>, <span class="st">"posest_sxi"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Additional columns for analysis (labor force variables):</span></span>
<span><span class="va">analysis_vars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"VD4001"</span>, <span class="st">"VD4002"</span><span class="op">)</span>  <span class="co"># Labor force status, occupation status</span></span>
<span></span>
<span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 2: Validate input data</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="va">validation</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/validate_pnadc.html">validate_pnadc</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>, stop_on_error <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">validation</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Check data coverage</span></span>
<span><span class="va">pnadc_stacked</span><span class="op">[</span>, <span class="va">.N</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">Ano</span>, <span class="va">Trimestre</span><span class="op">)</span><span class="op">]</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="va">Ano</span>, <span class="va">Trimestre</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 3: Build crosswalk (identify reference periods)</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="co"># This identifies months, fortnights, and weeks for all observations</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Output:</p>
<pre><code>Building reference period crosswalk...
  Preprocessing data (shared computation)...
  Converting date bounds to period positions...
  Aggregating constraints and determining periods...
  Applying exception rules...
  Assigning reference periods...
  Building crosswalk...

Crosswalk complete:
  - 9,598,723 unique household-quarter observations
  - Month determination: 96.69%
  - Fortnight determination: 7.64%
  - Week determination: 1.54%</code></pre>
<div class="sourceCode" id="cb49"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Check determination rates by year</span></span>
<span><span class="va">crosswalk</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  n <span class="op">=</span> <span class="va">.N</span>,</span>
<span>  det_month <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_month</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">*</span> <span class="fl">100</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  det_fortnight <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_fortnight</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">*</span> <span class="fl">100</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  det_week <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_week</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">*</span> <span class="fl">100</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="va">Ano</span><span class="op">]</span></span></code></pre></div>
<p>Output (from real PNADC 2012-2025 data):</p>
<pre><code>      Ano       n det_month det_fortnight det_week
    &lt;int&gt;   &lt;int&gt;     &lt;num&gt;         &lt;num&gt;    &lt;num&gt;
 1:  2012  695083      96.3           8.5      1.7
 2:  2013  719697      98.7           8.5      1.4
 3:  2014  739655      98.4           8.1      1.3
 4:  2015  745247      98.2           8.1      1.6
 5:  2016  749631      97.2           7.7      2.1
 6:  2017  752066      96.9           7.5      1.8
 7:  2018  750274      97.1           7.6      1.5
 8:  2019  746873      97.6           7.8      1.3
 9:  2020  535970      96.3           7.6      1.3
10:  2021  544817      93.3           6.9      1.9
11:  2022  679389      95.0           7.1      1.7
12:  2023  690749      96.2           7.1      1.7
13:  2024  708340      97.3           7.3      1.3
14:  2025  540932      93.1           6.9      1.0</code></pre>
<div class="sourceCode" id="cb51"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 4: Apply crosswalk and calibrate monthly weights</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_stacked</span>,</span>
<span>  <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"month"</span>,</span>
<span>  calibrate <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  keep_all <span class="op">=</span> <span class="cn">TRUE</span>,  <span class="co"># Keep indeterminate observations (with NA weights)</span></span>
<span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Verify population totals match SIDRA</span></span>
<span><span class="va">result</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">weight_monthly</span><span class="op">)</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  pop_millions <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_monthly</span><span class="op">)</span> <span class="op">/</span> <span class="fl">1e6</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="va">ref_month_yyyymm</span><span class="op">]</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="va">ref_month_yyyymm</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 5: Compute monthly estimates</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="co"># Calculate monthly unemployment rate</span></span>
<span><span class="va">monthly_labor</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  labor_force <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_monthly</span> <span class="op">*</span> <span class="op">(</span><span class="va">VD4001</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  employed <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_monthly</span> <span class="op">*</span> <span class="op">(</span><span class="va">VD4002</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  n_obs <span class="op">=</span> <span class="va">.N</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">ref_month_yyyymm</span>, <span class="va">ref_month_start</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="va">monthly_labor</span><span class="op">[</span>, <span class="va">unemployment_rate</span> <span class="op">:=</span> <span class="op">(</span><span class="va">labor_force</span> <span class="op">-</span> <span class="va">employed</span><span class="op">)</span> <span class="op">/</span> <span class="va">labor_force</span> <span class="op">*</span> <span class="fl">100</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># Check sample sizes</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">monthly_labor</span><span class="op">$</span><span class="va">n_obs</span><span class="op">)</span>  <span class="co"># Should be ~65,000+ per month</span></span>
<span></span>
<span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 6: Visualize results</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="co"># Basic plot (requires ggplot2)</span></span>
<span><span class="co"># library(ggplot2)</span></span>
<span><span class="co"># ggplot(monthly_labor, aes(x = ref_month_start, y = unemployment_rate)) +</span></span>
<span><span class="co">#   geom_line() +</span></span>
<span><span class="co">#   geom_point(size = 1) +</span></span>
<span><span class="co">#   labs(title = "Monthly Unemployment Rate - Brazil",</span></span>
<span><span class="co">#        subtitle = "From PNADC quarterly data using PNADCperiods",</span></span>
<span><span class="co">#        x = NULL, y = "Unemployment Rate (%)") +</span></span>
<span><span class="co">#   theme_minimal()</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="key-takeaways">Key Takeaways<a class="anchor" aria-label="anchor" href="#key-takeaways"></a>
</h3>
<ol style="list-style-type: decimal">
<li><p><strong>Stack data first</strong>: Load 2+ years before calling
<code><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods()</a></code> to maximize determination
rate.</p></li>
<li><p><strong>Validate inputs</strong>: Use
<code><a href="../reference/validate_pnadc.html">validate_pnadc()</a></code> to catch missing columns early.</p></li>
<li><p><strong>Check determination rates</strong>: Rates should be
~96-99% for stable years. Lower rates suggest data issues or boundary
effects.</p></li>
<li><p><strong>Use <code>keep_all = TRUE</code></strong>: Preserves all
observations; indeterminate ones get <code>NA</code> weights.</p></li>
<li><p><strong>Weight smoothing</strong> (<code>smooth = TRUE</code> by
default): Keep enabled for trend analysis; disable for shock/event
analysis.</p></li>
<li><p><strong>Verify population totals</strong>: Monthly weighted sums
should approximate Brazil’s population (~206 million in 2024).</p></li>
</ol>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="further-reading">Further Reading<a class="anchor" aria-label="anchor" href="#further-reading"></a>
</h2>
<ul>
<li>
<a href="applied-examples.html">Applied Examples</a> - See the
algorithm in action with COVID, recession, and minimum wage
validation</li>
<li>
<a href="annual-poverty-analysis.html">Annual Poverty Analysis</a> -
Monthly poverty analysis with annual PNADC income data</li>
<li><a href="https://www.ibge.gov.br/estatisticas/sociais/trabalho/9171-pesquisa-nacional-por-amostra-de-domicilios-continua-mensal.html" class="external-link">IBGE
PNADC Documentation</a></li>
<li>Package function reference: <code><a href="../reference/pnadc_identify_periods.html">?pnadc_identify_periods</a></code>,
<code><a href="../reference/pnadc_apply_periods.html">?pnadc_apply_periods</a></code>
</li>
<li>Source code: <a href="https://github.com/antrologos/PNADCperiods" class="external-link">GitHub
repository</a>
</li>
</ul>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://orcid.org/0000-0002-6796-4547" class="external-link">Rogerio Barbosa</a>, <a href="https://orcid.org/0000-0002-5449-6787" class="external-link">Marcos Hecksher</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
