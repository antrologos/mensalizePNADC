<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>How PNADCperiods Works • PNADCperiods</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="How PNADCperiods Works">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">PNADCperiods</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">2.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../articles/getting-started.html">Get Started</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/download-and-prepare.html">Download and Prepare Data</a></li>
    <li><a class="dropdown-item" href="../articles/applied-examples.html">Applied Examples</a></li>
    <li><a class="dropdown-item" href="../articles/annual-poverty-analysis.html">Annual Poverty Analysis</a></li>
    <li><a class="dropdown-item" href="../articles/complex-survey-design.html">Complex Survey Design</a></li>
    <li><a class="dropdown-item" href="../articles/how-it-works.html">How PNADCperiods Works</a></li>
  </ul>
</li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/antrologos/mensalizePNADC/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>How PNADCperiods Works</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/antrologos/mensalizePNADC/blob/HEAD/vignettes/how-it-works.Rmd" class="external-link"><code>vignettes/how-it-works.Rmd</code></a></small>
      <div class="d-none name"><code>how-it-works.Rmd</code></div>
    </div>

    
    
<!--
MAINTAINER NOTE:
This vignette uses eval=FALSE for all code chunks.
Pre-computed figures and tables are generated by:
  code/generate_how_it_works_figures.R

Figures are stored in: vignettes/figures/how-it-works/
Tables are stored in: output/vignette/tables/how-it-works/

To regenerate, run the generation script. The script caches intermediate
results in data/processed/ for faster subsequent runs.
-->
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>This vignette explains <strong>how the PNADCperiods algorithm
works</strong>: the methodology behind converting Brazil’s quarterly
PNADC survey into sub-quarterly time series with calibrated weights. For
practical usage examples, see the <a href="getting-started.html">Get
Started</a> vignette.</p>
<div class="section level3">
<h3 id="what-this-package-does">What This Package Does<a class="anchor" aria-label="anchor" href="#what-this-package-does"></a>
</h3>
<p>The <code>PNADCperiods</code> package transforms Brazil’s quarterly
PNADC (Pesquisa Nacional por Amostra de Domicilios Continua) survey data
into finer-grained time series for labor market, demographic, and
socioeconomic analysis. It addresses a fundamental challenge: PNADC
reports quarterly aggregates, but policy analysis often requires
understanding what happened within specific months, fortnights, or
weeks.</p>
<p><strong>Package capabilities:</strong></p>
<ol style="list-style-type: decimal">
<li>
<strong>Multi-granularity period identification</strong>: Determines
which specific time period each observation refers to
<ul>
<li>
<strong>Monthly</strong> (~97% determination rate) - suitable for
most analyses</li>
<li>
<strong>Fortnight</strong> (~3% determination rate) - for
specialized short-term analysis</li>
<li>
<strong>Weekly</strong> (~1% determination rate) - for
high-frequency monitoring</li>
</ul>
</li>
<li>
<strong>Flexible weight calibration</strong>: Adjusts survey weights
for sub-quarterly estimates
<ul>
<li>Calibrates to official monthly population totals (SIDRA API)</li>
<li>Adaptive hierarchical raking (4/2/1 cell levels depending on sample
size)</li>
<li>Adaptive smoothing to remove quarterly artifacts (3/7/none
periods)</li>
</ul>
</li>
<li>
<strong>Dual data format support</strong>: Works with both quarterly
and annual PNADC releases
<ul>
<li>
<strong>Quarterly data</strong> (V1028 weights) - labor market
variables, all rotation groups</li>
<li>
<strong>Annual data</strong> (V1032 weights) - comprehensive income
(VD5008), single visit</li>
</ul>
</li>
</ol>
</div>
<div class="section level3">
<h3 id="why-this-matters">Why This Matters<a class="anchor" aria-label="anchor" href="#why-this-matters"></a>
</h3>
<p>Policy questions often require sub-quarterly precision that raw PNADC
data cannot provide:</p>
<ul>
<li>When exactly did unemployment spike during COVID-19? (March 2020
vs. January 2020)</li>
<li>How quickly did labor markets respond to minimum wage changes?
(month-to-month transitions)</li>
<li>What was poverty in December 2023 specifically? (not just Q4 2023
average)</li>
</ul>
<p>The algorithm exploits PNADC’s rotating panel design and birthday
information to recover this temporal precision. By identifying when each
household was actually interviewed within the quarter, we can construct
monthly time series with 97% of the original sample retained.</p>
</div>
<div class="section level3">
<h3 id="what-youll-learn">What You’ll Learn<a class="anchor" aria-label="anchor" href="#what-youll-learn"></a>
</h3>
<p>This vignette walks through the complete methodology:</p>
<ol style="list-style-type: decimal">
<li>
<strong>Why stacked multi-quarter data matters</strong> - How
cross-quarter aggregation improves determination from ~70% to ~97%</li>
<li>
<strong>The core algorithm</strong> (8-step pipeline):
<ul>
<li>Valid interview date calculation (IBGE timing rules)</li>
<li>Birthday constraints to narrow date ranges</li>
<li>UPA-panel aggregation (households interviewed together)</li>
<li>Cross-quarter constraint propagation</li>
<li>Dynamic exception detection for edge cases</li>
</ul>
</li>
<li>
<strong>Weight calibration approaches</strong>:
<ul>
<li>Quarterly data: redistribute quarterly totals across 3 months</li>
<li>Annual data: redistribute yearly totals across 12 months</li>
<li>Fortnight/weekly data: simplified raking for smaller samples</li>
</ul>
</li>
<li>
<strong>Performance characteristics</strong> - Determination rates,
processing speed, data quality</li>
<li>
<strong>Best practices</strong> - Input data requirements, handling
indeterminate cases, validation</li>
</ol>
</div>
<div class="section level3">
<h3 id="prerequisites">Prerequisites<a class="anchor" aria-label="anchor" href="#prerequisites"></a>
</h3>
<p>This vignette assumes you’re already familiar with basic PNADC
concepts (UPA, rotation groups, survey weights) and have seen the
package in action via the <a href="getting-started.html">Get Started</a>
vignette. We focus here on <strong>understanding the
methodology</strong> rather than <strong>how to use the
functions</strong>.</p>
<p>If you’re looking for applied examples with real policy questions,
see the <a href="applied-examples.html">Applied Examples</a> vignette.
For poverty analysis using annual PNADC data, see <a href="annual-poverty-analysis.html">Annual Poverty Analysis</a>.</p>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="quick-reference">Quick Reference<a class="anchor" aria-label="anchor" href="#quick-reference"></a>
</h2>
<div class="section level3">
<h3 id="required-input-variables">Required Input Variables<a class="anchor" aria-label="anchor" href="#required-input-variables"></a>
</h3>
<p><strong>Minimum (for reference month identification):</strong></p>
<table class="table">
<thead><tr class="header">
<th>Column</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>Ano</code></td>
<td>Survey year</td>
</tr>
<tr class="even">
<td><code>Trimestre</code></td>
<td>Quarter (1-4)</td>
</tr>
<tr class="odd">
<td><code>UPA</code></td>
<td>Primary Sampling Unit</td>
</tr>
<tr class="even">
<td><code>V1014</code></td>
<td>Panel identifier</td>
</tr>
<tr class="odd">
<td><code>V1008</code></td>
<td>Household identifier</td>
</tr>
<tr class="even">
<td><code>V2003</code></td>
<td>Person identifier</td>
</tr>
<tr class="odd">
<td><code>V2008</code></td>
<td>Birth day (1-31, or 99 for unknown)</td>
</tr>
<tr class="even">
<td><code>V20081</code></td>
<td>Birth month (1-12, or 99 for unknown)</td>
</tr>
<tr class="odd">
<td><code>V20082</code></td>
<td>Birth year (or 9999 for unknown)</td>
</tr>
<tr class="even">
<td><code>V2009</code></td>
<td>Age</td>
</tr>
</tbody>
</table>
<p><strong>Additional (for <code>calibrate = TRUE</code> in
<code><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods()</a></code>):</strong></p>
<table class="table">
<thead><tr class="header">
<th>Variable</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>V1028</code></td>
<td>Original quarterly survey weight</td>
</tr>
<tr class="even">
<td><code>V1032</code></td>
<td>Original annual survey weight (for annual data only)</td>
</tr>
<tr class="odd">
<td><code>UF</code></td>
<td>State code</td>
</tr>
<tr class="even">
<td><code>posest</code></td>
<td>Post-stratification cell</td>
</tr>
<tr class="odd">
<td><code>posest_sxi</code></td>
<td>Post-stratification group</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="output-variables">Output Variables<a class="anchor" aria-label="anchor" href="#output-variables"></a>
</h3>
<table class="table">
<colgroup>
<col width="34%">
<col width="20%">
<col width="44%">
</colgroup>
<thead><tr class="header">
<th>Variable</th>
<th>Type</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>ref_month</code></td>
<td>Date</td>
<td>First day of reference month (e.g., “2023-01-01”)</td>
</tr>
<tr class="even">
<td><code>ref_month_in_quarter</code></td>
<td>Integer</td>
<td>Position: 1, 2, 3, or NA if indeterminate</td>
</tr>
<tr class="odd">
<td><code>ref_month_yyyymm</code></td>
<td>Integer</td>
<td>YYYYMM format (e.g., 202301)</td>
</tr>
<tr class="even">
<td><code>weight_monthly</code></td>
<td>Numeric</td>
<td>Monthly weight (if <code>calibrate = TRUE</code>); NA for
indeterminate</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="functions">Functions<a class="anchor" aria-label="anchor" href="#functions"></a>
</h3>
<table class="table">
<colgroup>
<col width="43%">
<col width="56%">
</colgroup>
<thead><tr class="header">
<th>Function</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods()</a></code></td>
<td>Main function: build crosswalk with months/fortnights/weeks</td>
</tr>
<tr class="even">
<td><code><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods()</a></code></td>
<td>Apply crosswalk + calibrate weights (quarterly or annual)</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/identify_reference_month.html">identify_reference_month()</a></code></td>
<td>Just reference month identification</td>
</tr>
<tr class="even">
<td><code><a href="../reference/identify_reference_fortnight.html">identify_reference_fortnight()</a></code></td>
<td>Fortnight (quinzena) identification</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/identify_reference_week.html">identify_reference_week()</a></code></td>
<td>Week identification</td>
</tr>
<tr class="even">
<td><code><a href="../reference/calibrate_monthly_weights.html">calibrate_monthly_weights()</a></code></td>
<td>Rake weighting for monthly weights (quarterly data)</td>
</tr>
<tr class="odd">
<td><code><a href="../reference/fetch_monthly_population.html">fetch_monthly_population()</a></code></td>
<td>Fetch population from SIDRA API</td>
</tr>
<tr class="even">
<td><code><a href="../reference/validate_pnadc.html">validate_pnadc()</a></code></td>
<td>Input data validation</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="performance-summary">Performance Summary<a class="anchor" aria-label="anchor" href="#performance-summary"></a>
</h3>
<table class="table">
<colgroup>
<col width="50%">
<col width="50%">
</colgroup>
<thead><tr class="header">
<th>Metric</th>
<th>Result</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Monthly determination rate</td>
<td>
<strong>97.0%</strong> (full history, 2012-2025)</td>
</tr>
<tr class="even">
<td>Fortnight determination rate</td>
<td><strong>3.0%</strong></td>
</tr>
<tr class="odd">
<td>Weekly determination rate</td>
<td><strong>0.9%</strong></td>
</tr>
<tr class="even">
<td>Processing time (basic mode)</td>
<td>
<strong>~1 minute</strong> for 28.4M rows (~450,000 rows/sec)</td>
</tr>
<tr class="odd">
<td>Processing time (with weights)</td>
<td><strong>~5 minutes</strong></td>
</tr>
<tr class="even">
<td>Best period (2013-2019)</td>
<td>97.7% monthly determination</td>
</tr>
<tr class="odd">
<td>COVID period (2020-2021)</td>
<td>94.7% monthly determination</td>
</tr>
</tbody>
</table>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="why-stacked-data-matters">Why Stacked Data Matters<a class="anchor" aria-label="anchor" href="#why-stacked-data-matters"></a>
</h2>
<p>The algorithm achieves <strong>97% determination rate</strong> when
processing <strong>stacked multi-quarter data</strong>. If you process
quarters individually, you’ll only get ~73% determination.</p>
<p>The figure below shows how determination rate improves as more
quarters are stacked, computed from real PNADC data (2012-2025):</p>
<div class="float">
<img src="figures/how-it-works/fig-determination-rate.png" style="width:100.0%" alt="Determination rate improves with more stacked quarters"><div class="figcaption">Determination rate improves with more stacked
quarters</div>
</div>
<p><strong>Empirical determination rates by number of quarters
stacked</strong> (from real PNADC 2012-2025 data):</p>
<table class="table">
<thead><tr class="header">
<th>Quarters Stacked</th>
<th>Observations</th>
<th>Determination Rate</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>1 (single quarter)</td>
<td>566,873</td>
<td>73.0%</td>
</tr>
<tr class="even">
<td>2</td>
<td>1,133,889</td>
<td>88.2%</td>
</tr>
<tr class="odd">
<td>4 (1 year)</td>
<td>2,252,464</td>
<td>93.9%</td>
</tr>
<tr class="even">
<td>8 (2 years)</td>
<td>4,530,641</td>
<td>96.3%</td>
</tr>
<tr class="odd">
<td>12 (3 years)</td>
<td>6,828,144</td>
<td>97.1%</td>
</tr>
<tr class="even">
<td>20 (5 years)</td>
<td>11,391,346</td>
<td>97.3%</td>
</tr>
<tr class="odd">
<td>32 (8 years)</td>
<td>18,088,581</td>
<td><strong>97.4%</strong></td>
</tr>
<tr class="even">
<td>55 (full history)</td>
<td>28,395,273</td>
<td>97.0%</td>
</tr>
</tbody>
</table>
<p>Note that the rate peaks around 32 quarters and then stabilizes. This
is because the boundary quarters (first 4 and last 4 of any series) have
inherently lower rates due to incomplete panel coverage.</p>
<p><strong>Why does stacking help?</strong> PNADC uses a
<strong>rotating panel</strong> where each household (UPA + V1014) is
interviewed for 5 consecutive quarters. Crucially, the same household is
always interviewed in the <strong>same relative month position</strong>
(always month 1, always month 2, or always month 3).</p>
<p>This means birthday constraints from <strong>any quarter</strong> can
determine the month for <strong>all quarters</strong>:</p>
<pre><code>UPA=123456, V1014=1 appears in 5 quarters:

  2023-Q1: month_min=1, month_max=2 (ambiguous: Jan or Feb)
  2023-Q2: month_min=1, month_max=3 (ambiguous: Apr, May, or Jun)
  2023-Q3: month_min=2, month_max=2 (DETERMINED: August)  ← Birthday constraint!
  2023-Q4: month_min=1, month_max=2 (ambiguous: Oct or Nov)
  2024-Q1: month_min=2, month_max=3 (ambiguous: Feb or Mar)

Cross-quarter aggregation:
  upa_month_min = max(1, 1, 2, 1, 2) = 2
  upa_month_max = min(2, 3, 2, 2, 3) = 2

Result: ALL 5 quarters → ref_month_in_quarter = 2</code></pre>
<p><strong>Recommended</strong>: Stack at least 2 years (8 quarters) of
data before calling <code><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods()</a></code> to achieve
&gt;96% determination.</p>
<hr>
</div>
<div class="section level2">
<h2 id="the-algorithm-explained">The Algorithm Explained<a class="anchor" aria-label="anchor" href="#the-algorithm-explained"></a>
</h2>
<p>This section details how the package identifies reference periods
(months, fortnights, and weeks) for each observation. The algorithm
shares initial computation steps across all three period types, then
diverges based on each period’s aggregation scope.</p>
<div class="section level3">
<h3 id="overview-diagram">Overview Diagram<a class="anchor" aria-label="anchor" href="#overview-diagram"></a>
</h3>
<p>The reference period identification follows a pipeline with shared
initial steps and period-specific aggregation:</p>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────┐
│                    REFERENCE PERIOD IDENTIFICATION PIPELINE                 │
│                       (Months, Fortnights, and Weeks)                       │
└─────────────────────────────────────────────────────────────────────────────┘

INPUTS (per observation):
┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│     Year     │  │    Quarter   │  │    Birthday  │  │      Age     │
│    (Ano)     │  │  (Trimestre) │  │  (V2008/1/2) │  │    (V2009)   │
└──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘
        │                │                  │                 │
        └────────────────┴──────────────────┴─────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                        SHARED COMPUTATION (All Periods)                     │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  STEP 1: Calculate Valid Interview Saturdays (IBGE Rules)                   │
│          Output: date_min, date_max for each quarter                        │
│                                                                             │
│  STEP 2: Apply Birthday Constraints                                         │
│          Narrow date window using age vs birth year comparison              │
│                                                                             │
│  STEP 3: Convert Dates to Period Positions                                  │
│          Compute: month_min/max, fortnight_min/max, week_min/max            │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
            ┌───────────────────────┼───────────────────────┐
            │                       │                       │
            ▼                       ▼                       ▼
┌───────────────────────┐ ┌───────────────────────┐ ┌───────────────────────┐
│   MONTH PIPELINE      │ │ FORTNIGHT PIPELINE    │ │   WEEK PIPELINE       │
│   (Steps 4-7)         │ │ (Steps 4-5)           │ │   (Steps 4-5)         │
├───────────────────────┤ ├───────────────────────┤ ├───────────────────────┤
│                       │ │                       │ │                       │
│ Step 4: Aggregate at  │ │ Step 4: Aggregate at  │ │ Step 4: Aggregate at  │
│   (UPA, V1014) level  │ │   (Ano, Trim, UPA,    │ │   (Ano, Trim, UPA,    │
│                       │ │    V1008) level       │ │    V1008) level       │
│ Step 5: CROSS-QUARTER │ │                       │ │                       │
│   aggregation across  │ │ NO cross-quarter      │ │ NO cross-quarter      │
│   ALL quarters        │ │ aggregation possible  │ │ aggregation possible  │
│                       │ │                       │ │                       │
│ Step 6: Dynamic       │ │ Step 5: Final         │ │ Step 5: Final         │
│   exception detection │ │   assignment          │ │   assignment          │
│                       │ │                       │ │                       │
│ Step 7: Final         │ │                       │ │                       │
│   assignment          │ │                       │ │                       │
│                       │ │                       │ │                       │
└───────────────────────┘ └───────────────────────┘ └───────────────────────┘
            │                       │                       │
            ▼                       ▼                       ▼
┌───────────────────────┐ ┌───────────────────────┐ ┌───────────────────────┐
│ Determination: ~97%   │ │ Determination: ~3%    │ │ Determination: ~1%    │
│                       │ │                       │ │                       │
│ OUTPUT:               │ │ OUTPUT:               │ │ OUTPUT:               │
│ - ref_month (Date)    │ │ - ref_fortnight       │ │ - ref_week (Date)     │
│ - ref_month_in_qtr    │ │ - ref_fortnight_in_q  │ │ - ref_week_in_qtr     │
│ - ref_month_yyyymm    │ │ - ref_fortnight_yyyyff│ │ - ref_week_yyyyww     │
└───────────────────────┘ └───────────────────────┘ └───────────────────────┘</code></pre>
<p><strong>Key insight</strong>: The critical difference is that
<strong>months benefit from cross-quarter aggregation</strong> (Step 5
in the month pipeline), while fortnights and weeks cannot aggregate
constraints across quarters. This is why the monthly determination rate
(~97%) far exceeds fortnights (~3%) and weeks (~1%).</p>
<hr>
</div>
<div class="section level3">
<h3 id="shared-computation-steps-1-3">Shared Computation (Steps 1-3)<a class="anchor" aria-label="anchor" href="#shared-computation-steps-1-3"></a>
</h3>
<p>The following three steps are computed once and shared across all
period types (months, fortnights, and weeks).</p>
<div class="section level4">
<h4 id="step-1-valid-interview-saturdays-ibge-rules">Step 1: Valid Interview Saturdays (IBGE Rules)<a class="anchor" aria-label="anchor" href="#step-1-valid-interview-saturdays-ibge-rules"></a>
</h4>
<p>As previously stated, IBGE defines that a reference week belongs to a
month only if it has at least <strong>4 days within that month</strong>.
Since reference weeks end on Saturdays, we look at the Saturdays of each
month to determine valid interview dates.</p>
<p><strong>How we calculate the first valid Saturday:</strong></p>
<pre><code>first_saturday_day = day of the first Saturday of the month
if first_saturday_day &gt;= 4:
    use this Saturday (it has enough days in the month)
else:
    use the second Saturday (first_saturday_day + 7)</code></pre>
<p><strong>Example for Q1 2023:</strong></p>
<pre><code>JANUARY 2023:
  Sun  Mon  Tue  Wed  Thu  Fri  SAT
   1    2    3    4    5    6   [7]  &lt;- First Saturday is day 7
                                     7 &gt;= 4? YES -&gt; Valid! (7 days in January)

FEBRUARY 2023:
  Wed  Thu  Fri  SAT  ...
   1    2    3   [4]              &lt;- First Saturday is day 4
                                  4 &gt;= 4? YES -&gt; Valid! (4 days in February)

APRIL 2023:
  SAT  Sun  Mon  Tue  ...
  [1]   2    3    4              &lt;- First Saturday is day 1
                                  1 &gt;= 4? NO -&gt; Skip to second Saturday!
  Fri  SAT  Sun  ...
   7   [8]   9                   &lt;- Use day 8 instead</code></pre>
<p>The valid Saturday calculation defines the <strong>possible interview
date range</strong> for the quarter: - <code>date_min</code> = First
valid Saturday of Month 1 - <code>date_max</code> = First valid Saturday
of Month 3 + 21 days</p>
<hr>
</div>
</div>
<div class="section level3">
<h3 id="step-2-birthday-constraints">Step 2: Birthday Constraints<a class="anchor" aria-label="anchor" href="#step-2-birthday-constraints"></a>
</h3>
<p>IBGE calculates age precisely using the precise birthdate and the
interview reference date (and most persons inform birthdates). In other
words, IBGE <strong>calculates age on the Saturday</strong> that ends
the reference week of the interview.</p>
<p>So, comparing the calculated age to the birth year, we can determine
if the interview (i.e. the reference date) happened before or after the
person’s birthday that year. This allows us to further narrow down the
possible interview date window.</p>
<pre><code>visit_before_birthday = (Survey_Year - Birth_Year) - Calculated_Age

If = 0: Interview was AFTER birthday (person already celebrated this year)
If = 1: Interview was BEFORE birthday (birthday hasn't happened yet)</code></pre>
<p><strong>Example: Interview AFTER birthday</strong></p>
<pre><code>Person: Born March 15, 1990
Survey Year and quarter: 2023 Q1
Calculated Age: 33

Check age: 2023 - 1990 = 33
           33 - 33 = 0  -&gt; Interview was AFTER March 15, 2023

Check first Saturday on or after birthday:
           first_Saturday_on_or_after(March 15) = March 18, 2023

New date constraints: 
            date_min = max(date_min, first_Saturday_on_or_after(March 15))                        
            date_min = max(Jan 7, March 18) = March 18

This person can only have been interviewed in MARCH (Month 3 of Q1).</code></pre>
<p><strong>Example: Interview BEFORE birthday</strong></p>
<pre><code>Person: Born February 17, 1990
Survey Year and quarter: 2023 Q1
Calculated Age: 32

Check age: 2023 - 1990 = 33
           33 - 32 = 1  -&gt; Interview was BEFORE February 17, 2023

Check first Saturday on or after birthday:
           first_Saturday_on_or_after(February 17) = February 18, 2023 (Sat)
           Saturday_before = February 18 - 7 = February 11, 2023

Constraint: date_max = min(date_max, Saturday_before(birthday))
            date_max = min(March 25, February 11) = February 11

This person can only have been interviewed in JANUARY or early FEBRUARY.</code></pre>
<p><strong>Unknown birthdays</strong>: When V2008=99, V20081=99, or
V20082=9999, that person’s birthday cannot constrain the date. However,
they may still be determined through aggregation by UPA-Panel level
(Step 4) or cross-quarter aggregation (Step 5).</p>
<hr>
</div>
<div class="section level3">
<h3 id="step-3-date-to-period-position">Step 3: Date to Period Position<a class="anchor" aria-label="anchor" href="#step-3-date-to-period-position"></a>
</h3>
<p>Transform the date window [date_min, date_max] into period positions.
This step works similarly for all three granularities:</p>
<p><strong>Month positions (1, 2, or 3):</strong></p>
<pre><code>For date_min: if day &lt;= 3 AND not in first month of quarter:
              subtract 1 from month position

For date_max: if day &lt;= 3:
              use the month of (date - 3 days) instead</code></pre>
<p><strong>Boundary handling</strong>: Interviews on days 1-3 of a month
typically belong to a reference week that started in the previous
month.</p>
<p><strong>Fortnight positions (1-6):</strong></p>
<p>After determining the month position, fortnights are calculated
as:</p>
<pre><code>fortnight_pos = (month_pos - 1) * 2 + half_of_month
  where half_of_month = 1 if day &lt;= 15, else 2</code></pre>
<table class="table">
<thead><tr class="header">
<th>Month</th>
<th>Days 1-15</th>
<th>Days 16-31</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>Fortnight 1</td>
<td>Fortnight 2</td>
</tr>
<tr class="even">
<td>2</td>
<td>Fortnight 3</td>
<td>Fortnight 4</td>
</tr>
<tr class="odd">
<td>3</td>
<td>Fortnight 5</td>
<td>Fortnight 6</td>
</tr>
</tbody>
</table>
<p><strong>Week positions (ISO week number):</strong></p>
<p>Weeks use the ISO 8601 standard for consistent numbering:</p>
<pre><code><span><span class="va">week_yyyyww</span> <span class="op">=</span> <span class="va">YYYY</span> <span class="op">*</span> <span class="fl">100</span> <span class="op">+</span> <span class="va">ISO_week_number</span></span></code></pre>
<p>ISO weeks: - Start on Monday - Week 1 is the first week containing at
least 4 days of the new year - Can span year boundaries (e.g., December
30 might be in week 1 of next year)</p>
<p>The resulting period positions feed into Step 4 (aggregation), which
differs by period type. See the separate pipelines below for months,
fortnights, and weeks.</p>
<hr>
</div>
<div class="section level3">
<h3 id="month-identification-pipeline-steps-4-7">Month Identification Pipeline (Steps 4-7)<a class="anchor" aria-label="anchor" href="#month-identification-pipeline-steps-4-7"></a>
</h3>
<p>The month identification pipeline uses cross-quarter aggregation to
achieve ~97% determination. This is the most powerful identification
because the same UPA-V1014 panel group is always interviewed in the same
relative month across all their quarterly visits.</p>
<div class="section level4">
<h4 id="step-4-upa-panel-aggregation">Step 4: UPA-Panel Aggregation<a class="anchor" aria-label="anchor" href="#step-4-upa-panel-aggregation"></a>
</h4>
<p>All people in the same <strong>UPA + V1014</strong> are interviewed
together in the <strong>same reference month</strong>. Take the
intersection:</p>
<pre><code>upa_month_min = MAX of all individual month_min_pos
upa_month_max = MIN of all individual month_max_pos</code></pre>
<p><strong>Example:</strong></p>
<pre><code>A household located at UPA=123456 and member of the Panel group V1014=1 has 3 members:

Person A: month_min=1, month_max=2 (could be Jan or Feb)
Person B: month_min=1, month_max=3 (could be Jan, Feb, or Mar)
Person C: month_min=2, month_max=3 (could be Feb or Mar)

Aggregation:
  upa_month_min = max(1, 1, 2) = 2
  upa_month_max = min(2, 3, 3) = 2

Result: min=2, max=2 -&gt; Reference month is FEBRUARY!

Visual:
              Jan    Feb    Mar
Person A:     [=========]
Person B:     [============]
Person C:            [========]
Intersection:        [==]      &lt;- Only February satisfies all</code></pre>
<p><strong>Note</strong>: Fortnights and weeks use a different
aggregation key — see the Fortnight and Week Identification section
below.</p>
</div>
<div class="section level4">
<h4 id="step-5-cross-quarter-aggregation">Step 5: Cross-Quarter Aggregation<a class="anchor" aria-label="anchor" href="#step-5-cross-quarter-aggregation"></a>
</h4>
<p>Since the relative month position is constant across quarters,
constraints from <strong>any</strong> quarter apply to
<strong>all</strong> quarters:</p>
<pre><code>For each (UPA, V1014) group across ALL quarters:
  upa_month_min = MAX of all month_min_pos from all quarters
  upa_month_max = MIN of all month_max_pos from all quarters</code></pre>
<p>This is why processing stacked data improves determination from ~70%
to ~97%.</p>
<p><strong>Critical distinction</strong>: This cross-quarter aggregation
is what makes monthly determination so effective (~97%), but it
<strong>cannot be applied to fortnights or weeks</strong>. Even though a
household is always interviewed in the same relative month (e.g., always
month 2), the specific fortnight or week within that month varies by
quarter. Therefore, fortnight and week constraints must be evaluated
within each quarter independently, resulting in much lower determination
rates (~2-5% for fortnights, ~1-2% for weeks).</p>
</div>
<div class="section level4">
<h4 id="step-6-dynamic-exception-detection">Step 6: Dynamic Exception Detection<a class="anchor" aria-label="anchor" href="#step-6-dynamic-exception-detection"></a>
</h4>
<p>In some quarters, the standard rule (first reference week with ≥4
days) may produce impossible results. For instance,
<code>upa_month_min &gt; upa_month_max</code>. Quarters in which this
happens are flagged as needing an exception. We then implement an
<strong>alternative rule</strong>: first reference week with ≥3 days</p>
<p><strong>How dynamic detection works</strong>: The algorithm
calculates month positions using both rules simultaneously:</p>
<table class="table">
<thead><tr class="header">
<th>Rule</th>
<th>First reference week</th>
<th>Day Threshold</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Standard</td>
<td>&gt;=4 days in month</td>
<td>day &lt;= 3</td>
</tr>
<tr class="even">
<td>Alternative</td>
<td>&gt;=3 days in month</td>
<td>day &lt;= 2</td>
</tr>
</tbody>
</table>
<p>Exceptions are detected and applied at the month level within each
quarter. For example, in 2016q3, only month 3 (September) needs the
exception – months 1 and 2 use the standard rule. Here’s why: under the
standard rule, September’s first valid Saturday would be September 10th
(since September 3rd has only 3 days in the month). But some UPA-V1014
groups have constraints that require September 3rd to be valid. The
exception rule (≥3 days instead of ≥4) makes September 3rd valid for
these groups, assigning the week of August 28th-September 3rd to
September’s reference month rather than August’s.</p>
<p>And the algorithm proceeds as follows:</p>
<pre><code>For each UPA-V1014:
  1. Calculate upa_month_min/max using STANDARD rules
  2. Also calculate alt_upa_month_min/max using ALTERNATIVE rules
  3. Check if exception is needed. ALL conditions must be true:
     a) Standard produces impossible result: upa_month_min &gt; upa_month_max
     b) Alternative would work: alt_upa_month_min &lt;= alt_upa_month_max
     c) Individual's constraint is the binding one that could be relaxed
        (the individual's bound equals the UPA bound that would change)
  4. Determine WHICH month within the quarter needs the exception:
     - requires_exc_m1: Exception needed for month 1
     - requires_exc_m2: Exception needed for month 2
     - requires_exc_m3: Exception needed for month 3
  5. PROPAGATE: If ANY UPA in the quarter needs exception for a month,
     apply that exception to ALL observations in that quarter</code></pre>
<p>Exception quarters are detected automatically. Examples found in
2012-2025 data: 2016q3, 2016q4, 2017q2, 2022q3, 2023q2, 2024q1. The
algorithm will detect any new exceptions in future data.</p>
</div>
<div class="section level4">
<h4 id="step-7-final-assignment">Step 7: Final Assignment<a class="anchor" aria-label="anchor" href="#step-7-final-assignment"></a>
</h4>
<p>After applying exceptions: if
<code>upa_month_min == upa_month_max</code>, the reference month is
determined. Otherwise, it remains NA.</p>
<p><strong>What makes observations indeterminate (~3%)?</strong></p>
<p>This occurs when the available birth date information in a (UPA,
V1014) group is insufficient to narrow down the possibilities to a
single month. Several factors contribute:</p>
<ul>
<li>
<strong>Incomplete panel coverage</strong>: Some UPAs may have fewer
than the expected 5 visits in the dataset. The first and last 4 quarters
of any consecutive series will naturally have more UPAs with incomplete
visit histories due to the rotating panel design.</li>
<li>
<strong>Unit non-response</strong>: The survey targets 14 households
per UPA each quarter, but non-response reduces this. Fewer responding
households means fewer birthday constraints to narrow down the
month.</li>
<li>
<strong>Small household sizes</strong>: Households with fewer
members provide fewer birthday constraints.</li>
<li>
<strong>Missing birth dates</strong>: Not all respondents report
their date of birth. Higher item non-response reduces the available
constraints.</li>
<li>
<strong>Uninformative birthdays</strong>: Some reported birth dates
don’t help distinguish between months (e.g., birthdays outside the
quarter’s interview window).</li>
</ul>
<p>Indeterminate observations are then removed from monthly analysis (if
<code>keep_all = FALSE</code>) or assigned <code>month = NA</code> and
<code>weight_monthly = NA</code> (if <code>keep_all = TRUE</code>).</p>
<hr>
</div>
</div>
<div class="section level3">
<h3 id="fortnight-and-week-identification-pipeline-steps-4-5">Fortnight and Week Identification Pipeline (Steps 4-5)<a class="anchor" aria-label="anchor" href="#fortnight-and-week-identification-pipeline-steps-4-5"></a>
</h3>
<p>The package also identifies <strong>fortnights</strong> (quinzenas)
and <strong>weeks</strong> within each quarter. These use the same
shared computation (Steps 1-3) as months, but with a critical
difference: <strong>they cannot aggregate across quarters</strong>,
resulting in much lower determination rates.</p>
<div class="section level4">
<h4 id="why-lower-determination-rates">Why Lower Determination Rates?<a class="anchor" aria-label="anchor" href="#why-lower-determination-rates"></a>
</h4>
<table class="table">
<thead><tr class="header">
<th>Period</th>
<th>Determination Rate</th>
<th>Aggregation Scope</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><strong>Month</strong></td>
<td>~97%</td>
<td>Cross-quarter (UPA, V1014)</td>
</tr>
<tr class="even">
<td><strong>Fortnight</strong></td>
<td>~3%</td>
<td>Within-quarter (Ano, Trimestre, UPA, V1008)</td>
</tr>
<tr class="odd">
<td><strong>Week</strong></td>
<td>~1%</td>
<td>Within-quarter (Ano, Trimestre, UPA, V1008)</td>
</tr>
</tbody>
</table>
<p>The key difference: <strong>months benefit from cross-quarter
aggregation</strong> (Step 5), while fortnights and weeks cannot.</p>
<p><strong>Why can’t fortnights/weeks aggregate across
quarters?</strong></p>
<ul>
<li>A household’s <strong>relative month position</strong> is constant:
if interviewed in month 2 of Q1, they’re always interviewed in month 2
of every quarter.</li>
<li>But the <strong>specific fortnight or week</strong> varies: even if
always in month 2, they might be in fortnight 3 in Q1 but fortnight 4 in
Q2.</li>
<li>Therefore, fortnight/week constraints from different quarters cannot
be combined.</li>
</ul>
</div>
<div class="section level4">
<h4 id="fortnight-identification-algorithm">Fortnight Identification Algorithm<a class="anchor" aria-label="anchor" href="#fortnight-identification-algorithm"></a>
</h4>
<p>Fortnights divide the quarter into 6 periods (2 per month):</p>
<pre><code>Quarter structure:
Month 1: Fortnight 1, Fortnight 2
Month 2: Fortnight 3, Fortnight 4
Month 3: Fortnight 5, Fortnight 6</code></pre>
<p>The algorithm follows the same Steps 1-4 as months, but:</p>
<p><strong>Step 3 (Fortnight version)</strong>: Convert dates to
fortnight positions (1-6)</p>
<pre><code>For each date in the quarter:
  1. Determine which month (1, 2, or 3)
  2. Determine if first or second half of month:
     - Days 1-15: First fortnight
     - Days 16+: Second fortnight
  3. Calculate position: (month - 1) * 2 + half</code></pre>
<p><strong>Step 4 (Fortnight version)</strong>: Aggregate at household
level <strong>within quarter</strong></p>
<pre><code>For each (Ano, Trimestre, UPA, V1008) group:
  hh_fortnight_min = max(all individual fortnight_min_pos)
  hh_fortnight_max = min(all individual fortnight_max_pos)

If hh_fortnight_min == hh_fortnight_max -&gt; DETERMINED</code></pre>
<p><strong>No Step 5</strong>: Fortnights cannot use cross-quarter
aggregation.</p>
<p><strong>Output variables:</strong></p>
<table class="table">
<colgroup>
<col width="43%">
<col width="56%">
</colgroup>
<thead><tr class="header">
<th>Variable</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>ref_fortnight</code></td>
<td>First day of reference fortnight</td>
</tr>
<tr class="even">
<td><code>ref_fortnight_in_quarter</code></td>
<td>Position 1-6, or NA if indeterminate</td>
</tr>
<tr class="odd">
<td><code>ref_fortnight_yyyyff</code></td>
<td>YYYYFF format (e.g., 202303 = 3rd fortnight of 2023, i.e., Feb
1-15)</td>
</tr>
<tr class="even">
<td><code>determined_fortnight</code></td>
<td>Logical: TRUE if determined</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="week-identification-algorithm">Week Identification Algorithm<a class="anchor" aria-label="anchor" href="#week-identification-algorithm"></a>
</h4>
<p>Weeks divide the quarter into approximately 13 periods:</p>
<pre><code>Quarter structure (example):
Month 1: Weeks 1-4 (or 5, depending on calendar)
Month 2: Weeks 5-8 (or 4-8)
Month 3: Weeks 9-13 (or 8-13)</code></pre>
<p>The algorithm uses ISO week numbers for consistency:</p>
<p><strong>Step 3 (Week version)</strong>: Convert dates to ISO week
numbers</p>
<pre><code>For each date:
  ref_week_yyyyww = ISO week number (YYYYWW format)

ISO weeks start on Monday and can span year boundaries.
For example, week 1 of 2024 might include days from late December 2023.</code></pre>
<p><strong>Step 4 (Week version)</strong>: Aggregate at household level
<strong>within quarter</strong></p>
<pre><code>For each (Ano, Trimestre, UPA, V1008) group:
  hh_week_min = max(all individual week_min_yyyyww)
  hh_week_max = min(all individual week_max_yyyyww)

If hh_week_min == hh_week_max -&gt; DETERMINED</code></pre>
<p><strong>Output variables:</strong></p>
<table class="table">
<thead><tr class="header">
<th>Variable</th>
<th>Description</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>ref_week</code></td>
<td>First day (Monday) of reference week</td>
</tr>
<tr class="even">
<td><code>ref_week_in_quarter</code></td>
<td>Position 1-13, or NA if indeterminate</td>
</tr>
<tr class="odd">
<td><code>ref_week_yyyyww</code></td>
<td>ISO week format (e.g., 202315 = week 15 of 2023)</td>
</tr>
<tr class="even">
<td><code>determined_week</code></td>
<td>Logical: TRUE if determined</td>
</tr>
</tbody>
</table>
</div>
<div class="section level4">
<h4 id="practical-implications">Practical Implications<a class="anchor" aria-label="anchor" href="#practical-implications"></a>
</h4>
<p><strong>When to use each granularity:</strong></p>
<table class="table">
<colgroup>
<col width="35%">
<col width="35%">
<col width="29%">
</colgroup>
<thead><tr class="header">
<th>Granularity</th>
<th>Sample Size</th>
<th>Use Cases</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><strong>Monthly</strong></td>
<td>~97% of data</td>
<td>Most analyses: labor market trends, poverty dynamics</td>
</tr>
<tr class="even">
<td><strong>Fortnight</strong></td>
<td>~3% of data</td>
<td>Short-term shock analysis (requires large initial sample)</td>
</tr>
<tr class="odd">
<td><strong>Weekly</strong></td>
<td>~1% of data</td>
<td>High-frequency monitoring (limited reliability)</td>
</tr>
</tbody>
</table>
<p><strong>Important considerations:</strong></p>
<ol style="list-style-type: decimal">
<li><p><strong>Sample size decreases rapidly</strong>: With only ~3%
fortnight or ~1% week determination, you need very large initial
datasets to have meaningful sub-monthly samples.</p></li>
<li><p><strong>Not a filter problem</strong>: The low determination
rates are inherent to the methodology, not a bug. Birthday constraints
within a single quarter rarely narrow the interview date to a specific
fortnight or week.</p></li>
<li><p><strong>Weight calibration adapts</strong>: The package
automatically uses simplified raking (fewer cell levels) for
fortnights/weeks to handle smaller samples.</p></li>
</ol>
</div>
<div class="section level4">
<h4 id="usage-example">Usage Example<a class="anchor" aria-label="anchor" href="#usage-example"></a>
</h4>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Build crosswalk with all period types</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Check determination rates</span></span>
<span><span class="va">crosswalk</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  n_obs <span class="op">=</span> <span class="va">.N</span>,</span>
<span>  det_month <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_month</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  det_fortnight <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_fortnight</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  det_week <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_week</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">Ano</span>, <span class="va">Trimestre</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># For fortnight analysis, filter to determined observations</span></span>
<span><span class="va">fortnight_data</span> <span class="op">&lt;-</span> <span class="va">crosswalk</span><span class="op">[</span><span class="va">determined_fortnight</span> <span class="op">==</span> <span class="cn">TRUE</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">fortnight_data</span><span class="op">)</span> <span class="op">/</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">crosswalk</span><span class="op">)</span>  <span class="co"># ~3%</span></span>
<span></span>
<span><span class="co"># Apply crosswalk with fortnight calibration</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_data</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"fortnight"</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p>Output (from real PNADC 2012-2025 data):</p>
<pre><code>Building reference period crosswalk...
  Preprocessing data (shared computation)...
  Converting date bounds to period positions...
  Aggregating constraints and determining periods...
  Applying exception rules...
  Assigning reference periods...
  Building crosswalk...

Crosswalk complete:
  - 9,769,932 unique household-quarter observations
  - Month determination: 97.0%
  - Fortnight determination: 2.9%
  - Week determination: 0.9%

# Sample determination rates by quarter (2023):
     Ano Trimestre   n_obs det_month det_fortnight det_week
   &lt;int&gt;     &lt;int&gt;   &lt;int&gt;     &lt;num&gt;         &lt;num&gt;    &lt;num&gt;
1:  2023         1  169879     0.954         0.027    0.010
2:  2023         2  171776     0.960         0.027    0.006
3:  2023         3  175418     0.965         0.039    0.010
4:  2023         4  173676     0.968         0.037    0.010</code></pre>
<hr>
</div>
</div>
</div>
<div class="section level2">
<h2 id="weight-calibration">Weight Calibration<a class="anchor" aria-label="anchor" href="#weight-calibration"></a>
</h2>
<p>For sub-quarterly aggregate estimates, you need appropriately
calibrated survey weights. The package supports calibration for all
three period types: monthly, fortnightly, and weekly.</p>
<div class="section level3">
<h3 id="how-calibration-works-general-principles">How Calibration Works (General Principles)<a class="anchor" aria-label="anchor" href="#how-calibration-works-general-principles"></a>
</h3>
<p>When <code>calibrate = TRUE</code> in
<code><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods()</a></code>, the package:</p>
<p><strong>1. Fetches monthly population from SIDRA API</strong> (table
6022)</p>
<p>SIDRA provides <strong>moving-quarter</strong> population estimates,
not exact monthly values:</p>
<table class="table">
<thead><tr class="header">
<th>SIDRA Code</th>
<th>3-Month Window</th>
<th>Represents Population For</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>201203</td>
<td>Jan+Feb+Mar 2012</td>
<td><strong>February 2012</strong></td>
</tr>
<tr class="even">
<td>201204</td>
<td>Feb+Mar+Apr 2012</td>
<td><strong>March 2012</strong></td>
</tr>
<tr class="odd">
<td>201205</td>
<td>Mar+Apr+May 2012</td>
<td><strong>April 2012</strong></td>
</tr>
</tbody>
</table>
<p>The package shifts values to align with their center month. Boundary
months (Jan 2012, latest month) are extrapolated via quadratic
regression.</p>
<p><strong>2. Applies hierarchical rake weighting</strong> across nested
calibration cells:</p>
<table class="table">
<colgroup>
<col width="36%">
<col width="36%">
<col width="27%">
</colgroup>
<thead><tr class="header">
<th>Cell Level</th>
<th>Definition</th>
<th>Purpose</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><code>celula1</code></td>
<td>Age groups: 0-13, 14-29, 30-59, 60+</td>
<td>Demographic balance</td>
</tr>
<tr class="even">
<td><code>celula2</code></td>
<td>Post-stratum group + age</td>
<td>Regional-demographic balance</td>
</tr>
<tr class="odd">
<td><code>celula3</code></td>
<td>State (UF) + celula2</td>
<td>State-level balance</td>
</tr>
<tr class="even">
<td><code>celula4</code></td>
<td>Post-stratum (posest) + celula2</td>
<td>Fine geographic balance</td>
</tr>
</tbody>
</table>
<p>The number of cell levels used depends on the calibration unit (see
“Fortnight and Weekly Calibration” below). At each level, weights are
adjusted so period totals match anchor totals proportionally.</p>
<p><strong>3. Calibrates to monthly population totals</strong></p>
<p>Final scaling ensures monthly weighted totals match SIDRA population
(~206 million average).</p>
</div>
<div class="section level3">
<h3 id="monthly-calibration">Monthly Calibration<a class="anchor" aria-label="anchor" href="#monthly-calibration"></a>
</h3>
<p>Monthly calibration uses the full 4-level hierarchical raking because
the high determination rate (~97%) provides sufficient sample size in
each cell.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Apply crosswalk and calibrate monthly weights</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>, <span class="va">crosswalk</span>,</span>
<span>                               weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>                               anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>                               calibration_unit <span class="op">=</span> <span class="st">"month"</span>,  <span class="co"># default</span></span>
<span>                               calibrate <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Use weight_monthly for monthly estimates</span></span>
<span><span class="va">monthly_pop</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  population <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_monthly</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="va">ref_month_yyyymm</span><span class="op">]</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="fortnight-and-week-calibration">Fortnight and Week Calibration<a class="anchor" aria-label="anchor" href="#fortnight-and-week-calibration"></a>
</h3>
<p>The package also supports calibrating weights for fortnight and
weekly analysis using <code>calibration_unit = "fortnight"</code> or
<code>calibration_unit = "week"</code>.</p>
<p><strong>Population Targets</strong></p>
<p>All time periods are calibrated to the <strong>full Brazilian
population</strong> from SIDRA:</p>
<table class="table">
<thead><tr class="header">
<th>Calibration Unit</th>
<th>Population Target</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Month</td>
<td>SIDRA monthly population (~206 million)</td>
</tr>
<tr class="even">
<td>Fortnight</td>
<td>Full monthly population of the containing month</td>
</tr>
<tr class="odd">
<td>Week</td>
<td>Full monthly population of the containing month</td>
</tr>
</tbody>
</table>
<p>This means that if you sum <code>weight_fortnight</code> for a given
fortnight, or <code>weight_weekly</code> for a given week, you get the
total Brazilian population for that period (not a fraction of it).</p>
<p><strong>Simplified Hierarchical Raking</strong></p>
<p>Because fortnights and weeks have much lower determination rates
(~2-5% and ~1-2% respectively), the hierarchical raking is automatically
simplified to avoid sparse cell issues:</p>
<table class="table">
<colgroup>
<col width="31%">
<col width="18%">
<col width="31%">
<col width="18%">
</colgroup>
<thead><tr class="header">
<th>Calibration Unit</th>
<th>Det. Rate</th>
<th>Cell Levels Used</th>
<th>Rationale</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Month</td>
<td>~97%</td>
<td>4 levels (celula1-4)</td>
<td>~65,000+ obs/period allows fine cells</td>
</tr>
<tr class="even">
<td>Fortnight</td>
<td>2-5%</td>
<td>2 levels (celula1-2)</td>
<td>~3,000 obs/period; finer cells too sparse</td>
</tr>
<tr class="odd">
<td>Week</td>
<td>1-2%</td>
<td>1 level (celula1 only)</td>
<td>~500 obs/period; only age groups stable</td>
</tr>
</tbody>
</table>
<p>The algorithm also checks minimum cell sizes (default: 10
observations) and skips raking levels if cells become too sparse.</p>
<p><strong>Smoothing Behavior</strong></p>
<p>Smoothing to remove quarterly artifacts is also adapted:</p>
<table class="table">
<thead><tr class="header">
<th>Calibration Unit</th>
<th>Smoothing Window</th>
<th>Cell Level</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Month</td>
<td>3-period rolling mean</td>
<td>celula4</td>
</tr>
<tr class="even">
<td>Fortnight</td>
<td>7-period rolling mean</td>
<td>celula2</td>
</tr>
<tr class="odd">
<td>Week</td>
<td>No smoothing</td>
<td>N/A</td>
</tr>
</tbody>
</table>
<p>Weekly data skips smoothing entirely because the small sample sizes
make cell-level smoothing unstable.</p>
<p><strong>Usage Example</strong></p>
<div class="sourceCode" id="cb24"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Fortnight calibration</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span><span class="va">pnadc_data</span>, <span class="va">crosswalk</span>,</span>
<span>                               weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>                               anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>                               calibration_unit <span class="op">=</span> <span class="st">"fortnight"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Weekly calibration</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span><span class="va">pnadc_data</span>, <span class="va">crosswalk</span>,</span>
<span>                               weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>                               anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>                               calibration_unit <span class="op">=</span> <span class="st">"week"</span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="handling-indeterminate-observations">Handling Indeterminate Observations<a class="anchor" aria-label="anchor" href="#handling-indeterminate-observations"></a>
</h3>
<p>By default (<code>keep_all = TRUE</code>), all input rows are
returned, with <code>weight_monthly = NA</code> for indeterminate
observations:</p>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Build crosswalk and apply (returns all rows by default)</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">pnadc_full</span><span class="op">)</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span><span class="va">pnadc_full</span>, <span class="va">crosswalk</span>,</span>
<span>                               weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>                               anchor <span class="op">=</span> <span class="st">"quarter"</span><span class="op">)</span></span>
<span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">result</span><span class="op">)</span> <span class="op">==</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">pnadc_full</span><span class="op">)</span>  <span class="co"># TRUE - all rows returned</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">result</span><span class="op">$</span><span class="va">weight_monthly</span><span class="op">)</span><span class="op">)</span>  <span class="co"># ~3% of rows have NA weights</span></span>
<span></span>
<span><span class="co"># Use na.rm = TRUE when aggregating</span></span>
<span><span class="va">monthly_pop</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span>pop <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_monthly</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span><span class="op">)</span>, by <span class="op">=</span> <span class="va">ref_month_yyyymm</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># Filter to determined rows for analysis</span></span>
<span><span class="va">result_determined</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span><span class="op">]</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">result_determined</span><span class="op">)</span> <span class="op">&lt;</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">pnadc_full</span><span class="op">)</span>  <span class="co"># TRUE (~97% of rows)</span></span></code></pre></div>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="weight-smoothing">Weight Smoothing<a class="anchor" aria-label="anchor" href="#weight-smoothing"></a>
</h2>
<p>During weight calibration, the package can optionally apply smoothing
to reduce artificial quarterly patterns in the calibrated weights. This
is controlled by the <code>smooth</code> parameter in
<code><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods()</a></code> (default: <code>TRUE</code>).</p>
<div class="section level3">
<h3 id="why-weight-smoothing-helps">Why Weight Smoothing Helps<a class="anchor" aria-label="anchor" href="#why-weight-smoothing-helps"></a>
</h3>
<p>PNADC’s quarterly structure creates subtle artifacts in monthly
estimates:</p>
<ol style="list-style-type: decimal">
<li><p><strong>Rotation group composition varies by month</strong>: Each
quarter has 5 rotation groups, but their distribution across months
isn’t perfectly even. Some months may have slightly more observations
from groups with different demographic compositions.</p></li>
<li><p><strong>Boundary effects</strong>: The first and last months of a
quarter can have different characteristics than middle months due to how
interviews are scheduled around “Parada Tecnica” (technical
breaks).</p></li>
<li><p><strong>Cell-level imbalances</strong>: Within demographic cells
(age × region × stratum), the month-to-month sample sizes can vary,
creating artificial jumps even when the true population is
stable.</p></li>
</ol>
<p>Weight smoothing addresses these issues by applying a rolling mean to
the calibration adjustments at the cell level, reducing artificial
volatility while preserving genuine trends.</p>
</div>
<div class="section level3">
<h3 id="how-weight-smoothing-works">How Weight Smoothing Works<a class="anchor" aria-label="anchor" href="#how-weight-smoothing-works"></a>
</h3>
<p>During calibration, the package applies rolling mean smoothing to
cell-level population ratios:</p>
<pre><code>For each (cell, period):
  1. Calculate cell population: pop_cell_period = sum(weights)
  2. Apply rolling mean across periods within cell:
     pop_smoothed = frollmean(pop_cell_period, window, align="center")
  3. Calculate smoothing factor: factor = pop_smoothed / pop_cell_period
  4. Adjust individual weights: weight_new = weight_old * factor</code></pre>
<p>The smoothing window adapts by time period granularity:</p>
<table class="table">
<thead><tr class="header">
<th>Period</th>
<th>Window</th>
<th>Rationale</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Month</td>
<td>3 periods</td>
<td>Captures quarter-to-quarter transitions</td>
</tr>
<tr class="even">
<td>Fortnight</td>
<td>7 periods</td>
<td>Wider window for more volatile estimates</td>
</tr>
<tr class="odd">
<td>Week</td>
<td>None</td>
<td>Sample too small for stable smoothing</td>
</tr>
</tbody>
</table>
</div>
<div class="section level3">
<h3 id="when-to-disable-smoothing">When to Disable Smoothing<a class="anchor" aria-label="anchor" href="#when-to-disable-smoothing"></a>
</h3>
<p>By default, <code>smooth = TRUE</code> is recommended for most
analyses. However, you may want to disable smoothing
(<code>smooth = FALSE</code>) in certain situations:</p>
<p><strong>Disable smoothing when:</strong></p>
<ul>
<li><p><strong>Analyzing rapid shocks</strong>: When studying events
with genuine month-to-month discontinuities (e.g., COVID-19 lockdown
effects in March 2020, sudden policy changes), smoothing may blur the
true timing of the effect.</p></li>
<li><p><strong>Studying short-term dynamics</strong>: When the research
question focuses on immediate month-to-month changes rather than
trends.</p></li>
<li><p><strong>Comparing specific months</strong>: When comparing the
same month across different years (e.g., December 2022 vs December
2023), smoothing may introduce bias from adjacent months.</p></li>
</ul>
<p><strong>Keep smoothing enabled when:</strong></p>
<ul>
<li>Computing time series for publication or visualization</li>
<li>Analyzing gradual trends (employment growth, demographic
shifts)</li>
<li>The underlying phenomenon is expected to change smoothly over
time</li>
</ul>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># With smoothing (default) - recommended for most analyses</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_data</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  smooth <span class="op">=</span> <span class="cn">TRUE</span>  <span class="co"># default</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Without smoothing - for shock analysis</span></span>
<span><span class="va">result_unsmoothed</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_data</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  smooth <span class="op">=</span> <span class="cn">FALSE</span></span>
<span><span class="op">)</span></span></code></pre></div>
<p><strong>Note</strong>: Smoothing is applied to the microdata weights
during calibration. If you still observe quarterly artifacts in your
final aggregated estimates, this may indicate genuine sampling variation
rather than calibration artifacts.</p>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="applying-the-crosswalk">Applying the Crosswalk<a class="anchor" aria-label="anchor" href="#applying-the-crosswalk"></a>
</h2>
<p>The package uses a <strong>two-step workflow</strong> to convert
PNADC data into sub-quarterly time series:</p>
<ol style="list-style-type: decimal">
<li>
<strong><code><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods()</a></code></strong>: Build a
crosswalk that identifies reference periods (months, fortnights, weeks)
for each household-quarter observation</li>
<li>
<strong><code><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods()</a></code></strong>: Merge this
crosswalk with your PNADC data and optionally calibrate weights</li>
</ol>
<p>This separation is deliberate: the crosswalk is built once from
stacked quarterly data (which contains birthday variables), then applied
to either quarterly or annual datasets for analysis.</p>
<div class="section level3">
<h3 id="the-two-step-workflow">The Two-Step Workflow<a class="anchor" aria-label="anchor" href="#the-two-step-workflow"></a>
</h3>
<pre><code>┌─────────────────────────────────────────────────────────────────────────────┐
│                        TWO-STEP WORKFLOW                                     │
└─────────────────────────────────────────────────────────────────────────────┘

STEP 1: Build Crosswalk (run once, from quarterly data)
┌───────────────────────────────────────────────────────────────────────┐
│ pnadc_identify_periods(quarterly_stacked)                             │
│                                                                       │
│ Input:  Stacked quarterly PNADC (needs birthday variables)            │
│ Output: Crosswalk with ref_month, ref_fortnight, ref_week per         │
│         (UPA, V1014) household-panel group                            │
└───────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
STEP 2: Apply to Target Data (run for each analysis)
┌───────────────────────────────────────────────────────────────────────┐
│ pnadc_apply_periods(target_data, crosswalk, ...)                      │
│                                                                       │
│ Input:  Any PNADC data (quarterly OR annual) + crosswalk              │
│ Output: Data with reference periods + calibrated weights              │
│                                                                       │
│ Key parameters:                                                       │
│   - weight_var: "V1028" (quarterly) or "V1032" (annual)               │
│   - anchor: "quarter" (quarterly) or "year" (annual)                  │
│   - calibration_unit: "month", "fortnight", or "week"                 │
└───────────────────────────────────────────────────────────────────────┘</code></pre>
</div>
<div class="section level3">
<h3 id="quarterly-vs--annual-pnadc-data">Quarterly vs. Annual PNADC Data<a class="anchor" aria-label="anchor" href="#quarterly-vs--annual-pnadc-data"></a>
</h3>
<p>PNADC has two main data releases that require different
approaches:</p>
<table class="table">
<colgroup>
<col width="22%">
<col width="41%">
<col width="36%">
</colgroup>
<thead><tr class="header">
<th>Aspect</th>
<th>Quarterly Data</th>
<th>Annual Data</th>
</tr></thead>
<tbody>
<tr class="odd">
<td><strong>Primary focus</strong></td>
<td>Labor market (employment, unemployment)</td>
<td>Income and poverty</td>
</tr>
<tr class="even">
<td><strong>Key income variable</strong></td>
<td>Limited (labor income only)</td>
<td>VD5008 (comprehensive household income)</td>
</tr>
<tr class="odd">
<td><strong>Weight variable</strong></td>
<td>V1028 (quarterly weight)</td>
<td>V1032 (annual/visit-specific weight)</td>
</tr>
<tr class="even">
<td><strong>Panel coverage</strong></td>
<td>All 5 rotation groups mixed</td>
<td>One specific visit (e.g., visit 1 or visit 5)</td>
</tr>
<tr class="odd">
<td><strong>Monthly observations</strong></td>
<td>~20% from each visit</td>
<td>100% from single visit</td>
</tr>
<tr class="even">
<td><strong>Function call</strong></td>
<td><code>anchor = "quarter"</code></td>
<td><code>anchor = "year"</code></td>
</tr>
</tbody>
</table>
<p><strong>Key insight</strong>: Reference period identification works
identically for both data types (birthday constraints don’t depend on
weight variables). The difference is in <strong>weight
calibration</strong>: quarterly weights distribute quarterly totals
across 3 months, while annual weights distribute yearly totals across 12
months.</p>
</div>
<div class="section level3">
<h3 id="applying-to-quarterly-data">Applying to Quarterly Data<a class="anchor" aria-label="anchor" href="#applying-to-quarterly-data"></a>
</h3>
<p>Use <code>anchor = "quarter"</code> with quarterly PNADC data (V1028
weights):</p>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Build crosswalk from stacked quarterly data</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">pnadc_stacked</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Apply to quarterly data with monthly weights</span></span>
<span><span class="va">result_monthly</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_quarterly</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"month"</span>,</span>
<span>  calibrate <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Apply with fortnight weights (for short-term analysis)</span></span>
<span><span class="va">result_fortnight</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_quarterly</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"fortnight"</span>,</span>
<span>  calibrate <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Apply with weekly weights (for high-frequency monitoring)</span></span>
<span><span class="va">result_weekly</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_quarterly</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"week"</span>,</span>
<span>  calibrate <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="applying-to-annual-data">Applying to Annual Data<a class="anchor" aria-label="anchor" href="#applying-to-annual-data"></a>
</h3>
<p>Use <code>anchor = "year"</code> with annual PNADC data (V1032
weights). Note that <strong>the crosswalk is still built from quarterly
data</strong> (which contains the birthday variables needed for period
identification).</p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Step 1: Build crosswalk from quarterly data</span></span>
<span><span class="va">quarterly_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="http://www.fstpackage.org/reference/write_fst.html" class="external-link">read_fst</a></span><span class="op">(</span><span class="st">"pnadc_quarterly_stacked.fst"</span>, as.data.table <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">quarterly_data</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Step 2: Load annual data with income variables</span></span>
<span><span class="va">annual_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="http://www.fstpackage.org/reference/write_fst.html" class="external-link">read_fst</a></span><span class="op">(</span><span class="st">"pnadc_2023_visita1.fst"</span>, as.data.table <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Step 3: Apply crosswalk with annual calibration</span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">annual_data</span>, <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1032"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"year"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"month"</span>,</span>
<span>  calibrate <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Use for monthly income/poverty analysis</span></span>
<span><span class="va">monthly_income</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  mean_income <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/stats/weighted.mean.html" class="external-link">weighted.mean</a></span><span class="op">(</span><span class="va">VD5008</span>, <span class="va">weight_monthly</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="va">ref_month_yyyymm</span><span class="op">]</span></span></code></pre></div>
<p>Annual data can also be calibrated at fortnight or week level by
changing <code>calibration_unit</code>.</p>
</div>
<div class="section level3">
<h3 id="covid-era-visit-selection">COVID-Era Visit Selection<a class="anchor" aria-label="anchor" href="#covid-era-visit-selection"></a>
</h3>
<p>For annual data, you must choose which panel visit to use. During
COVID-19 (2020-2021), visit 1 was often unavailable:</p>
<table class="table">
<thead><tr class="header">
<th>Period</th>
<th>Recommended Visit</th>
<th>Reason</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>2015-2019</td>
<td>Visit 1</td>
<td>Standard practice</td>
</tr>
<tr class="even">
<td>2020-2021</td>
<td>Visit 5</td>
<td>COVID-era data collection issues</td>
</tr>
<tr class="odd">
<td>2022-2024</td>
<td>Visit 1</td>
<td>Post-pandemic normalization</td>
</tr>
</tbody>
</table>
<p>For a complete example of poverty analysis with annual data, see the
<a href="annual-poverty-analysis.html">Annual Poverty Analysis</a>
vignette.</p>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="advanced-usage">Advanced Usage<a class="anchor" aria-label="anchor" href="#advanced-usage"></a>
</h2>
<div class="section level3">
<h3 id="using-modular-functions">Using Modular Functions<a class="anchor" aria-label="anchor" href="#using-modular-functions"></a>
</h3>
<p>For more control, use the individual identification functions:</p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Identify reference months only</span></span>
<span><span class="va">months</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/identify_reference_month.html">identify_reference_month</a></span><span class="op">(</span><span class="va">pnadc_stacked</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Identify fortnights only</span></span>
<span><span class="va">fortnights</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/identify_reference_fortnight.html">identify_reference_fortnight</a></span><span class="op">(</span><span class="va">pnadc_stacked</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Identify weeks only</span></span>
<span><span class="va">weeks</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/identify_reference_week.html">identify_reference_week</a></span><span class="op">(</span><span class="va">pnadc_stacked</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Check determination rates by quarter</span></span>
<span><span class="va">months</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  total <span class="op">=</span> <span class="va">.N</span>,</span>
<span>  determined <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span><span class="op">)</span>,</span>
<span>  rate <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span><span class="op">)</span> <span class="op">*</span> <span class="fl">100</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">Ano</span>, <span class="va">Trimestre</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<p>Output (sample from 2023, using real PNADC data):</p>
<pre><code>   Ano Trimestre  total determined  rate
 &lt;int&gt;     &lt;int&gt;  &lt;int&gt;      &lt;int&gt; &lt;num&gt;
1: 2023         1 169879     162107  95.4
2: 2023         2 171776     164920  96.0
3: 2023         3 175418     169215  96.5
4: 2023         4 173676     168094  96.8</code></pre>
</div>
<div class="section level3">
<h3 id="validation-and-population-data">Validation and Population Data<a class="anchor" aria-label="anchor" href="#validation-and-population-data"></a>
</h3>
<div class="sourceCode" id="cb33"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Validate input data before processing</span></span>
<span><span class="va">validation</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/validate_pnadc.html">validate_pnadc</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>, stop_on_error <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Fetch population data from SIDRA-IBGE manually (for inspection)</span></span>
<span><span class="va">pop_data</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/fetch_monthly_population.html">fetch_monthly_population</a></span><span class="op">(</span>verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">pop_data</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Note: pnadc_apply_periods() fetches population data automatically</span></span>
<span><span class="co"># when calibrate = TRUE. Manual fetching is only needed for inspection</span></span>
<span><span class="co"># or custom calibration workflows.</span></span></code></pre></div>
<p>Output (sample from fetch_monthly_population):</p>
<pre><code>Fetching monthly population data from SIDRA (table 6022)...
  Retrieved 159 rows for 2012-2025

   year_month population_total
        &lt;int&gt;            &lt;num&gt;
1:     201202        193146000
2:     201203        193470000
3:     201204        193804000
4:     201205        194138000
5:     201206        194469000
6:     201207        194788000</code></pre>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="performance">Performance<a class="anchor" aria-label="anchor" href="#performance"></a>
</h2>
<div class="section level3">
<h3 id="benchmarks">Benchmarks<a class="anchor" aria-label="anchor" href="#benchmarks"></a>
</h3>
<table class="table">
<thead><tr class="header">
<th>Dataset Size</th>
<th>Rows</th>
<th>Time (basic)</th>
<th>Throughput</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>1 quarter</td>
<td>~570K</td>
<td>~1.5 sec</td>
<td>~380K rows/sec</td>
</tr>
<tr class="even">
<td>1 year</td>
<td>~2.3M</td>
<td>~5 sec</td>
<td>~460K rows/sec</td>
</tr>
<tr class="odd">
<td>14 years (2012-2025)</td>
<td>28.4M</td>
<td><strong>~1 minute</strong></td>
<td>~450K rows/sec</td>
</tr>
</tbody>
</table>
<p><strong>Key optimization</strong>: The <code><a href="https://lubridate.tidyverse.org/reference/make_datetime.html" class="external-link">make_date()</a></code>
function uses pre-computed lookup tables instead of
<code><a href="https://rdrr.io/r/base/ISOdatetime.html" class="external-link">ISOdate()</a></code>, achieving <strong>20x speedup</strong> on date
operations.</p>
</div>
<div class="section level3">
<h3 id="determination-rates-by-period">Determination Rates by Period<a class="anchor" aria-label="anchor" href="#determination-rates-by-period"></a>
</h3>
<p>Based on real PNADC data (2012-2025, 55 quarters, 28.4M
observations):</p>
<table class="table">
<thead><tr class="header">
<th>Period</th>
<th>Quarters</th>
<th>Monthly Rate</th>
<th>Fortnight Rate</th>
<th>Week Rate</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>2012</td>
<td>Q1-Q4</td>
<td>91.4% - 98.8%</td>
<td>3.2% - 4.8%</td>
<td>1.2%</td>
</tr>
<tr class="even">
<td>2013-2019</td>
<td>28 quarters</td>
<td>96.8% - 98.8%</td>
<td>2.3% - 4.5%</td>
<td>0.6% - 1.2%</td>
</tr>
<tr class="odd">
<td>2020-2021</td>
<td>8 quarters</td>
<td>92.7% - 97.3%</td>
<td>1.9% - 2.9%</td>
<td>0.5% - 1.4%</td>
</tr>
<tr class="even">
<td>2022-2024</td>
<td>15 quarters</td>
<td>94.6% - 97.4%</td>
<td>2.0% - 3.9%</td>
<td>0.5% - 1.1%</td>
</tr>
<tr class="odd">
<td>2025</td>
<td>Q1-Q3</td>
<td>88.5% - 96.5%</td>
<td>2.7% - 3.0%</td>
<td>0.5% - 0.6%</td>
</tr>
</tbody>
</table>
<p><strong>Why boundary quarters have lower rates</strong>: The first 4
and last 4 quarters of any consecutive quarterly dataset will always
include (UPA, V1014) groups with fewer than 5 visits in the data. This
makes mensalization efficiency suboptimal at the boundaries. In a
dataset with 9 consecutive quarters, for example, only the 5th quarter
will have full utilization – because among people observed in the 5th
quarter, all of them will have all their visits in the data, from those
on their 1st visit in the 5th quarter to those on their 5th visit in the
5th quarter. This is an inherent consequence of PNADC’s rotating panel
design (5 visits over 5 quarters).</p>
</div>
<div class="section level3">
<h3 id="optimization-tips">Optimization Tips<a class="anchor" aria-label="anchor" href="#optimization-tips"></a>
</h3>
<ul>
<li>Use <code>data.table</code> directly (automatic conversion from
<code>data.frame</code> adds overhead)</li>
<li>Load only required columns when reading data</li>
<li>Process multiple years together (cross-quarter aggregation improves
accuracy)</li>
</ul>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="tips-and-best-practices">Tips and Best Practices<a class="anchor" aria-label="anchor" href="#tips-and-best-practices"></a>
</h2>
<ol style="list-style-type: decimal">
<li><p><strong>Process multiple quarters together</strong>: Processing
2012-2025 together gives ~97% determination vs ~73% for a single
quarter.</p></li>
<li><p><strong>Start with reference month identification</strong>: You
don’t always need monthly weights. Often just knowing the reference
month is enough.</p></li>
<li>
<p><strong>Check determination rates by year</strong>: Monthly rates
should be 97-99% for 2013-2019. Lower rates may indicate data
issues.</p>
<div class="sourceCode" id="cb35"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">crosswalk</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span>rate <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">Ano</span>, <span class="va">Trimestre</span><span class="op">)</span><span class="op">]</span></span></code></pre></div>
<p>Example output (2019):</p>
<pre><code>   Ano Trimestre   rate
 &lt;int&gt;     &lt;int&gt;  &lt;num&gt;
1: 2019         1 0.973
2: 2019         2 0.976
3: 2019         3 0.979
4: 2019         4 0.978</code></pre>
</li>
<li><p><strong>Handle indeterminate observations</strong>: Decide
whether to exclude them or use quarterly-level analysis for those
cases.</p></li>
<li><p><strong>Use <code>weight_monthly</code> for general
analysis</strong>: The rake-weighted output is appropriate for most
purposes.</p></li>
</ol>
<hr>
</div>
<div class="section level2">
<h2 id="complete-workflow-example">Complete Workflow Example<a class="anchor" aria-label="anchor" href="#complete-workflow-example"></a>
</h2>
<p>This section demonstrates the complete workflow from raw PNADC data
to monthly time series, incorporating all the concepts from this
vignette.</p>
<div class="section level3">
<h3 id="scenario-monthly-unemployment-analysis-2019-2024">Scenario: Monthly Unemployment Analysis (2019-2024)<a class="anchor" aria-label="anchor" href="#scenario-monthly-unemployment-analysis-2019-2024"></a>
</h3>
<div class="sourceCode" id="cb37"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://antrologos.github.io/mensalizePNADC/">PNADCperiods</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://r-datatable.com" class="external-link">data.table</a></span><span class="op">)</span></span>
<span></span>
<span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 1: Load and stack quarterly PNADC data</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="co"># Load quarterly data (recommend 2+ years for good determination rates)</span></span>
<span><span class="co"># Real data should be loaded from your files, e.g.:</span></span>
<span><span class="co"># files &lt;- list.files("path/to/data", pattern = "pnadc_.*\\.fst$", full.names = TRUE)</span></span>
<span><span class="co"># pnadc_stacked &lt;- rbindlist(lapply(files, fst::read_fst, as.data.table = TRUE))</span></span>
<span></span>
<span><span class="co"># Required columns for identification:</span></span>
<span><span class="va">required_id</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"Ano"</span>, <span class="st">"Trimestre"</span>, <span class="st">"UPA"</span>, <span class="st">"V1008"</span>, <span class="st">"V1014"</span>,</span>
<span>                 <span class="st">"V2003"</span>, <span class="st">"V2008"</span>, <span class="st">"V20081"</span>, <span class="st">"V20082"</span>, <span class="st">"V2009"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Additional columns for calibration:</span></span>
<span><span class="va">required_weights</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"V1028"</span>, <span class="st">"UF"</span>, <span class="st">"posest"</span>, <span class="st">"posest_sxi"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Additional columns for analysis (labor force variables):</span></span>
<span><span class="va">analysis_vars</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="st">"VD4001"</span>, <span class="st">"VD4002"</span><span class="op">)</span>  <span class="co"># Labor force status, occupation status</span></span>
<span></span>
<span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 2: Validate input data</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="va">validation</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/validate_pnadc.html">validate_pnadc</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>, stop_on_error <span class="op">=</span> <span class="cn">FALSE</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">validation</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Check data coverage</span></span>
<span><span class="va">pnadc_stacked</span><span class="op">[</span>, <span class="va">.N</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">Ano</span>, <span class="va">Trimestre</span><span class="op">)</span><span class="op">]</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="va">Ano</span>, <span class="va">Trimestre</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 3: Build crosswalk (identify reference periods)</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="co"># This identifies months, fortnights, and weeks for all observations</span></span>
<span><span class="va">crosswalk</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods</a></span><span class="op">(</span><span class="va">pnadc_stacked</span>, verbose <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></span></code></pre></div>
<p>Output:</p>
<pre><code>Building reference period crosswalk...
  Preprocessing data (shared computation)...
  Converting date bounds to period positions...
  Aggregating constraints and determining periods...
  Applying exception rules...
  Assigning reference periods...
  Building crosswalk...

Crosswalk complete:
  - 9,769,932 unique household-quarter observations
  - Month determination: 97.0%
  - Fortnight determination: 2.9%
  - Week determination: 0.9%</code></pre>
<div class="sourceCode" id="cb39"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Check determination rates by year</span></span>
<span><span class="va">crosswalk</span><span class="op">[</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  n <span class="op">=</span> <span class="va">.N</span>,</span>
<span>  det_month <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_month</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">*</span> <span class="fl">100</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  det_fortnight <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_fortnight</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">*</span> <span class="fl">100</span>, <span class="fl">1</span><span class="op">)</span>,</span>
<span>  det_week <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/Round.html" class="external-link">round</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean</a></span><span class="op">(</span><span class="va">determined_week</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span> <span class="op">*</span> <span class="fl">100</span>, <span class="fl">1</span><span class="op">)</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="va">Ano</span><span class="op">]</span></span></code></pre></div>
<p>Output (from real PNADC 2012-2025 data):</p>
<pre><code>      Ano       n det_month det_fortnight det_week
    &lt;int&gt;   &lt;int&gt;     &lt;num&gt;         &lt;num&gt;    &lt;num&gt;
 1:  2012  695083      96.3           4.0      1.2
 2:  2013  719697      98.7           3.5      0.9
 3:  2014  739655      98.4           3.2      0.7
 4:  2015  745247      98.2           2.7      0.9
 5:  2016  749631      97.2           2.3      0.9
 6:  2017  752066      96.9           3.4      1.0
 7:  2018  750274      97.1           3.5      1.1
 8:  2019  746873      97.6           3.2      0.9
 9:  2020  535970      96.2           2.6      0.7
10:  2021  544817      93.3           2.1      1.1
11:  2022  679389      95.0           2.6      0.9
12:  2023  690749      96.2           3.2      0.9
13:  2024  708340      97.3           3.1      0.9
14:  2025  540932      93.0           2.8      0.6</code></pre>
<div class="sourceCode" id="cb41"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 4: Apply crosswalk and calibrate monthly weights</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/pnadc_apply_periods.html">pnadc_apply_periods</a></span><span class="op">(</span></span>
<span>  <span class="va">pnadc_stacked</span>,</span>
<span>  <span class="va">crosswalk</span>,</span>
<span>  weight_var <span class="op">=</span> <span class="st">"V1028"</span>,</span>
<span>  anchor <span class="op">=</span> <span class="st">"quarter"</span>,</span>
<span>  calibration_unit <span class="op">=</span> <span class="st">"month"</span>,</span>
<span>  calibrate <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  keep_all <span class="op">=</span> <span class="cn">TRUE</span>,  <span class="co"># Keep indeterminate observations (with NA weights)</span></span>
<span>  verbose <span class="op">=</span> <span class="cn">TRUE</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Verify population totals match SIDRA</span></span>
<span><span class="va">result</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">weight_monthly</span><span class="op">)</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  pop_millions <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_monthly</span><span class="op">)</span> <span class="op">/</span> <span class="fl">1e6</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="va">ref_month_yyyymm</span><span class="op">]</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html" class="external-link">order</a></span><span class="op">(</span><span class="va">ref_month_yyyymm</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 5: Compute monthly estimates</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="co"># Calculate monthly unemployment rate</span></span>
<span><span class="va">monthly_labor</span> <span class="op">&lt;-</span> <span class="va">result</span><span class="op">[</span><span class="op">!</span><span class="fu"><a href="https://rdrr.io/r/base/NA.html" class="external-link">is.na</a></span><span class="op">(</span><span class="va">ref_month_in_quarter</span><span class="op">)</span>, <span class="fu">.</span><span class="op">(</span></span>
<span>  labor_force <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_monthly</span> <span class="op">*</span> <span class="op">(</span><span class="va">VD4001</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  employed <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/sum.html" class="external-link">sum</a></span><span class="op">(</span><span class="va">weight_monthly</span> <span class="op">*</span> <span class="op">(</span><span class="va">VD4002</span> <span class="op">==</span> <span class="fl">1</span><span class="op">)</span>, na.rm <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>,</span>
<span>  n_obs <span class="op">=</span> <span class="va">.N</span></span>
<span><span class="op">)</span>, by <span class="op">=</span> <span class="fu">.</span><span class="op">(</span><span class="va">ref_month_yyyymm</span>, <span class="va">ref_month</span><span class="op">)</span><span class="op">]</span></span>
<span></span>
<span><span class="va">monthly_labor</span><span class="op">[</span>, <span class="va">unemployment_rate</span> <span class="op">:=</span> <span class="op">(</span><span class="va">labor_force</span> <span class="op">-</span> <span class="va">employed</span><span class="op">)</span> <span class="op">/</span> <span class="va">labor_force</span> <span class="op">*</span> <span class="fl">100</span><span class="op">]</span></span>
<span></span>
<span><span class="co"># Check sample sizes</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/summary.html" class="external-link">summary</a></span><span class="op">(</span><span class="va">monthly_labor</span><span class="op">$</span><span class="va">n_obs</span><span class="op">)</span>  <span class="co"># Should be ~65,000+ per month</span></span>
<span></span>
<span><span class="co"># =============================================================================</span></span>
<span><span class="co"># STEP 6: Visualize results</span></span>
<span><span class="co"># =============================================================================</span></span>
<span></span>
<span><span class="co"># Basic plot (requires ggplot2)</span></span>
<span><span class="co"># library(ggplot2)</span></span>
<span><span class="co"># ggplot(monthly_labor, aes(x = ref_month, y = unemployment_rate)) +</span></span>
<span><span class="co">#   geom_line() +</span></span>
<span><span class="co">#   geom_point(size = 1) +</span></span>
<span><span class="co">#   labs(title = "Monthly Unemployment Rate - Brazil",</span></span>
<span><span class="co">#        subtitle = "From PNADC quarterly data using PNADCperiods",</span></span>
<span><span class="co">#        x = NULL, y = "Unemployment Rate (%)") +</span></span>
<span><span class="co">#   theme_minimal()</span></span></code></pre></div>
</div>
<div class="section level3">
<h3 id="key-takeaways">Key Takeaways<a class="anchor" aria-label="anchor" href="#key-takeaways"></a>
</h3>
<ol style="list-style-type: decimal">
<li><p><strong>Stack data first</strong>: Load 2+ years before calling
<code><a href="../reference/pnadc_identify_periods.html">pnadc_identify_periods()</a></code> to maximize determination
rate.</p></li>
<li><p><strong>Validate inputs</strong>: Use
<code><a href="../reference/validate_pnadc.html">validate_pnadc()</a></code> to catch missing columns early.</p></li>
<li><p><strong>Check determination rates</strong>: Rates should be
~96-99% for stable years. Lower rates suggest data issues or boundary
effects.</p></li>
<li><p><strong>Use <code>keep_all = TRUE</code></strong>: Preserves all
observations; indeterminate ones get <code>NA</code> weights.</p></li>
<li><p><strong>Weight smoothing</strong> (<code>smooth = TRUE</code> by
default): Keep enabled for trend analysis; disable for shock/event
analysis.</p></li>
<li><p><strong>Verify population totals</strong>: Monthly weighted sums
should approximate Brazil’s population (~206 million in 2024).</p></li>
</ol>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="further-reading">Further Reading<a class="anchor" aria-label="anchor" href="#further-reading"></a>
</h2>
<ul>
<li>
<a href="applied-examples.html">Applied Examples</a> - See the
algorithm in action with COVID, recession, and minimum wage
validation</li>
<li>
<a href="annual-poverty-analysis.html">Annual Poverty Analysis</a> -
Monthly poverty analysis with annual PNADC income data</li>
<li><a href="https://www.ibge.gov.br/estatisticas/sociais/trabalho/9171-pesquisa-nacional-por-amostra-de-domicilios-continua-mensal.html" class="external-link">IBGE
PNADC Documentation</a></li>
<li>Package function reference: <code><a href="../reference/pnadc_identify_periods.html">?pnadc_identify_periods</a></code>,
<code><a href="../reference/pnadc_apply_periods.html">?pnadc_apply_periods</a></code>
</li>
<li>Source code: <a href="https://github.com/antrologos/mensalizePNADC" class="external-link">GitHub
repository</a>
</li>
</ul>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by <a href="https://orcid.org/0000-0002-5449-6787" class="external-link">Marcos Hecksher</a>, <a href="https://orcid.org/0000-0002-6796-4547" class="external-link">Rogerio Barbosa</a>.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.3.</p>
</div>

    </footer>
</div>





  </body>
</html>
