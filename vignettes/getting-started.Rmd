---
title: "Get Started with mensalizePNADC"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get Started with mensalizePNADC}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

## Overview

The `mensalizePNADC` package converts Brazil's quarterly PNADC (Pesquisa Nacional por Amostra de Domicilios Continua) survey data into monthly time series. It identifies which specific month each survey observation refers to, achieving a **97% determination rate** on stacked multi-quarter data.

**Why does this matter?** PNADC quarterly statistics are actually moving averages of three months, which obscures:

- The true timing of economic shocks (when did unemployment peak?)
- The actual magnitude of changes (how high was the peak?)
- Turning points in trends (when did recovery begin?)

Mensalization recovers the specific reference month, enabling true monthly labor market analysis.

For a detailed explanation of the algorithm, see the [How mensalizePNADC Works](how-it-works.html) vignette.

---

## Installation

```{r install}
# Install from GitHub
devtools::install_github("antrologos/mensalizePNADC")
```
```{r}
# Load the package
library(mensalizePNADC)
library(data.table)
```

**Dependencies:**

- **Required**: `data.table`, `checkmate`
- **For weight calibration**: `sidrar` (fetches population data from IBGE's SIDRA API)

---

## Your First Mensalization

### Required Input Columns

The mensalization algorithm needs these columns from your PNADC data:

| Column | Description |
|--------|-------------|
| `Ano` | Survey year |
| `Trimestre` | Quarter (1-4) |
| `UPA` | Primary Sampling Unit |
| `V1014` | Panel identifier |
| `V1008` | Household identifier |
| `V2003` | Person identifier |
| `V2008` | Birth day (1-31, or 99 for unknown) |
| `V20081` | Birth month (1-12, or 99 for unknown) |
| `V20082` | Birth year (or 9999 for unknown) |
| `V2009` | Age |

### Step 1: Load Your Data

If you don't have stacked PNADC data yet, see [Download and Prepare Data](download-and-prepare.html) for a complete workflow.

```{r load-data}
# Load your stacked quarterly PNADC data
pnadc <- fread("pnadc_stacked.csv",
  select = c("Ano", "Trimestre", "UPA", "V1008", "V1014", "V2003",
             "V2008", "V20081", "V20082", "V2009"))

# Check data dimensions
cat("Rows:", nrow(pnadc), "\n")
cat("Quarters:", uniqueN(pnadc[, .(Ano, Trimestre)]), "\n")
```

**Important:** The algorithm works best with **stacked multi-quarter data**. Processing a single quarter yields only ~65-75% determination rate, while stacking 2+ years achieves ~97%.

### Step 2: Run Mensalization

```{r run-mensalize}
# Identify reference months
crosswalk <- mensalizePNADC(pnadc)
```

Expected output:
```
Validating input data...
Identifying reference months...
  Determination rate: 97.0%
```

### Step 3: Understand the Output

The function returns a `data.table` with the original identifier columns plus:

| Output Column | Type | Description |
|---------------|------|-------------|
| `ref_month` | Date | Reference month as Date (e.g., "2023-01-01") |
| `ref_month_in_quarter` | Integer | Position in quarter: 1, 2, 3, or NA |
| `ref_month_yyyymm` | Integer | YYYYMM format (e.g., 202301) |

```{r view-output}
# View the crosswalk
head(crosswalk)
#    Ano Trimestre    UPA V1008 V1014 V2003   ref_month ref_month_in_quarter ref_month_yyyymm
# 1: 2012         1 110000     1     1     1 2012-01-01                    1           201201
# 2: 2012         1 110000     1     1     2 2012-01-01                    1           201201

# Check the determination rate attribute
attr(crosswalk, "determination_rate")
# [1] 0.97
```

Observations with `ref_month_in_quarter = NA` are **indeterminate** -- the algorithm couldn't narrow down to a single month. This affects about 3% of observations.

### Step 4: Join with Original Data

```{r join-data}
# Load an original quarterly file with all variables you need
library(haven)
original <- read_dta("PNADC_2023T1.dta")

# Join to add monthly information
monthly_data <- merge(original, crosswalk,
  by = c("Ano", "Trimestre", "UPA", "V1008", "V1014", "V2003"),
  all.x = TRUE)
```

### Step 5: Use for Monthly Analysis

```{r use-monthly}
# Filter to a specific month
jan_2023 <- monthly_data[ref_month_yyyymm == 202301]

# Group by month
by_month <- monthly_data[, .(
  n_obs = .N,
  mean_age = weighted.mean(V2009, V1028, na.rm = TRUE)
), by = ref_month_yyyymm]

# Check determination rate by year
monthly_data[, .(
  total = .N,
  determined = sum(!is.na(ref_month_in_quarter)),
  rate = round(mean(!is.na(ref_month_in_quarter)) * 100, 1)
), by = Ano]
```

---

## Computing Monthly Weights

For proper monthly aggregate estimates, you need monthly-appropriate survey weights. The original PNADC weight (`V1028`) is designed for quarterly estimates.

### When Do You Need Monthly Weights?

- **Just reference months**: If you only need to know which month each observation belongs to, you don't need monthly weights
- **Monthly aggregates**: If you're computing weighted estimates (totals, means, rates) by month, use `weight_monthly`

### Additional Required Columns

For weight computation, you also need:

| Variable | Description |
|----------|-------------|
| `V1028` | Original quarterly survey weight |
| `UF` | State code |
| `posest` | Post-stratification cell |
| `posest_sxi` | Post-stratification group |

### Computing Weights

```{r compute-weights}
# Load full data with weight columns
pnadc_full <- fread("pnadc_stacked_full.csv")

# Run mensalization with weight computation
result <- mensalizePNADC(pnadc_full, compute_weights = TRUE, verbose = TRUE)
```

Expected output:
```
Validating input data...
Identifying reference months...
  Determination rate: 97.0%
Computing monthly weights...
  Fetching monthly population from SIDRA...
  Calibrating weights...
Done.
```

### Using Monthly Weights

```{r use-weights}
# Compute monthly unemployment rate
monthly_unemployment <- result[!is.na(weight_monthly), .(
  unemployment_rate = sum((VD4002 == 2) * weight_monthly, na.rm = TRUE) /
                      sum((VD4001 == 1) * weight_monthly, na.rm = TRUE)
), by = ref_month_yyyymm]

# Compute monthly population
monthly_pop <- result[, .(
  population = sum(weight_monthly, na.rm = TRUE)
), by = ref_month_yyyymm]
```

**Note:** Indeterminate observations have `weight_monthly = NA`. Always use `na.rm = TRUE` when aggregating, or filter to `!is.na(weight_monthly)`.

### Handling Indeterminate Observations

By default (`keep_all = TRUE`), all input rows are returned:

```{r keep-all}
# Default: all rows returned
result <- mensalizePNADC(pnadc_full, compute_weights = TRUE)
nrow(result) == nrow(pnadc_full)  # TRUE

# About 3% have NA weights
sum(is.na(result$weight_monthly)) / nrow(result)  # ~0.03

# Alternative: only return determined rows
result_determined <- mensalizePNADC(pnadc_full, compute_weights = TRUE, keep_all = FALSE)
nrow(result_determined) < nrow(pnadc_full)  # TRUE (~97% of rows)
```

---

## Understanding Determination Rates

### Why Stack Multiple Quarters?

PNADC uses a **rotating panel** where each household (identified by UPA + V1014) is interviewed in 5 consecutive quarters. The same household is always interviewed in the **same relative month position** within each quarter.

This means birthday constraints from **any** quarter can determine the month for **all** quarters:

```
UPA=123456, V1014=1 appears in 5 quarters:

  2023-Q1: could be Jan or Feb (ambiguous)
  2023-Q2: could be Apr, May, or Jun (ambiguous)
  2023-Q3: must be August (birthday constraint pins it down!)
  2023-Q4: could be Oct or Nov (ambiguous)
  2024-Q1: could be Feb or Mar (ambiguous)

Cross-quarter aggregation:
  Since 2023-Q3 must be month 2, ALL quarters must be month 2.
  Result: ALL 5 quarters are determined!
```

| Processing Mode | Determination Rate |
|-----------------|-------------------|
| Single quarter | 65-75% |
| Stacked (2+ years) | **97%** |

### What Makes Observations Indeterminate?

About 3% of observations remain indeterminate because:

- **Incomplete panel coverage**: First/last quarters in your data have fewer panel visits
- **Missing birth dates**: Some respondents don't report birth date (V2008=99, etc.)
- **Small households**: Fewer people means fewer birthday constraints
- **Unit non-response**: Some households don't respond in all quarters

For the full algorithm explanation, see [How mensalizePNADC Works](how-it-works.html).

---

## Next Steps

- **Download PNADC data**: See [Download and Prepare Data](download-and-prepare.html) for a complete workflow to download and stack quarterly microdata from IBGE.

- **Analysis examples**: See [Applied Examples](applied-examples.html) for real-world labor market analysis comparing monthly vs quarterly data, including COVID unemployment and minimum wage validation.

- **Function reference**: Browse the [Reference](../reference/index.html) for documentation of all exported functions.

---

## Quick Reference

### Functions

| Function | Description |
|----------|-------------|
| `mensalizePNADC()` | Main function: identify months + optional weights |
| `identify_reference_month()` | Just reference month identification |
| `calibrate_monthly_weights()` | Rake weighting for monthly weights |
| `smooth_monthly_aggregates()` | Remove quarterly artifacts from series |
| `fetch_monthly_population()` | Fetch population from SIDRA API |
| `validate_pnadc()` | Input data validation |

### Performance

| Metric | Value |
|--------|-------|
| Determination rate | **97.0%** (on stacked data) |
| Processing time (basic) | ~1 minute for 28M rows |
| Processing time (with weights) | ~5 minutes for 28M rows |
| Throughput | ~450,000 rows/second |
