---
title: "How mensalizePNADC Works"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{How mensalizePNADC Works}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

## Introduction

This vignette explains **how the mensalizePNADC algorithm works**: the methodology behind identifying reference months and computing monthly weights. For practical usage examples, see the [Get Started](getting-started.html) vignette.

The `mensalizePNADC` package converts Brazil's quarterly PNADC (Pesquisa Nacional por Amostra de Domicilios Continua) survey data into monthly time series. It provides two main capabilities:

1. **Reference month identification**: Determines which month within each quarter each survey observation refers to
2. **Monthly weight computation**: Adjusts survey weights for monthly (instead of quarterly) estimates

---

## Quick Reference

### Required Input Variables

**Minimum (for reference month identification):**

| Column | Description |
|--------|-------------|
| `Ano` | Survey year |
| `Trimestre` | Quarter (1-4) |
| `UPA` | Primary Sampling Unit |
| `V1014` | Panel identifier |
| `V1008` | Household identifier |
| `V2003` | Person identifier |
| `V2008` | Birth day (1-31, or 99 for unknown) |
| `V20081` | Birth month (1-12, or 99 for unknown) |
| `V20082` | Birth year (or 9999 for unknown) |
| `V2009` | Age |

**Additional (for `compute_weights = TRUE`):**

| Variable | Description |
|----------|-------------|
| `V1028` | Original quarterly survey weight |
| `UF` | State code |
| `posest` | Post-stratification cell |
| `posest_sxi` | Post-stratification group |

### Output Variables

| Variable | Type | Description |
|----------|------|-------------|
| `ref_month` | Date | First day of reference month (e.g., "2023-01-01") |
| `ref_month_in_quarter` | Integer | Position: 1, 2, 3, or NA if indeterminate |
| `ref_month_yyyymm` | Integer | YYYYMM format (e.g., 202301) |
| `weight_monthly` | Numeric | Monthly weight (if `compute_weights = TRUE`); NA for indeterminate |

### Functions

| Function | Description |
|----------|-------------|
| `mensalizePNADC()` | Main function: identify months + optional weights |
| `identify_reference_month()` | Just reference month identification |
| `calibrate_monthly_weights()` | Rake weighting for monthly weights |
| `smooth_monthly_aggregates()` | Remove quarterly artifacts from series |
| `fetch_monthly_population()` | Fetch population from SIDRA API |
| `validate_pnadc()` | Input data validation |

### Performance Summary

| Metric | Result |
|--------|--------|
| Overall determination rate | **97.0%** |
| Processing time (basic mode) | **~1 minute** for 28.4M rows (~450,000 rows/sec) |
| Processing time (with weights) | **~5 minutes** |
| Best period (2013-2019) | 96-99% determination |

---

## Why Stacked Data Matters

The algorithm achieves **97.0% determination rate** when processing **stacked multi-quarter data**. If you process quarters individually, you'll only get ~65-75% determination.

| Processing Mode | Determination Rate |
|-----------------|-------------------|
| Per-quarter (single quarter) | 65-75% |
| Stacked (multi-quarter) | **97.0%** |

**Why?** PNADC uses a **rotating panel** where each household (UPA + V1014) is interviewed for 5 consecutive quarters. Crucially, the same household is always interviewed in the **same relative month position** (always month 1, always month 2, or always month 3).

This means birthday constraints from **any quarter** can determine the month for **all quarters**:

```
UPA=123456, V1014=1 appears in 5 quarters:

  2023-Q1: month_min=1, month_max=2 (ambiguous: Jan or Feb)
  2023-Q2: month_min=1, month_max=3 (ambiguous: Apr, May, or Jun)
  2023-Q3: month_min=2, month_max=2 (DETERMINED: August)  ← Birthday constraint!
  2023-Q4: month_min=1, month_max=2 (ambiguous: Oct or Nov)
  2024-Q1: month_min=2, month_max=3 (ambiguous: Feb or Mar)

Cross-quarter aggregation:
  upa_month_min = max(1, 1, 2, 1, 2) = 2
  upa_month_max = min(2, 3, 2, 2, 3) = 2

Result: ALL 5 quarters → ref_month_in_quarter = 2
```

**Recommended**: Stack at least 2 years of quarterly data before calling `mensalizePNADC()`.

---

## The Algorithm Explained

### Overview Diagram

The reference month identification follows a 7-step pipeline:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    REFERENCE MONTH IDENTIFICATION PIPELINE                  │
└─────────────────────────────────────────────────────────────────────────────┘

INPUTS (per observation):
┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│     Year     │  │    Quarter   │  │    Birthday  │  │      Age     │
│    (Ano)     │  │  (Trimestre) │  │  (V2008/1/2) │  │    (V2009)   │
└──────────────┘  └──────────────┘  └──────────────┘  └──────────────┘
        │                │                  │                 │
        ▼                ▼                  ▼                 ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 1a: Calculate Valid Interview Weeks                                    │
│          (IBGE "Parada Tecnica" Rules)                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│  IBGE Rule: A reference week belongs to a month only if it has at least     │
│  4 days within the month.                                                   │
│                                                                             │
|  So, for finding the first reference week of IBGE interviews find the       |
|  Saturday of that month and count how many days it has been since 1st day.  |
│                                                                             │
|  If ≥4 days, that is considered a valid reference week.                     |
|  If less than 3 days, that short week will be considered a "technical stop" | 
|  Then skip to the next (second) Saturday                                    |
│                                                                             │
│  Saturdays are the reference day of each reference week. They are the dates |
|  the IBGE interviewers refer to in questions involving precise timing. So   │
│  the first Saturday of each month is also the first valid interview date    │
│  for that month                                                             │
│                                                                             │
│  OUTPUT: First reference day of Months 1, 2, and 3 of the quarter           │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 1b: Calculate the range of possible interview dates for each quarter   │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  Interviews (i.e. valid reference dates for interviews) within a quarter    │
│  can only have happened from the first valid Saturday of Month 1 up to the  │
│  last Saturday of Month 3 -- i.e. First Saturday of Month 3 + 21 days       │
│  (since reference weeks end on Saturdays). This gives us date bounds.       │   
│                                                                             │
│  OUTPUT: date_min = First Saturday of Month 1                               │
│          date_max = First Saturday of Month 3 + 21 days                     │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 2: Apply Birthday Constraints                                          │
├─────────────────────────────────────────────────────────────────────────────┤
│  Compare (Survey_Year - Birth_Year) with Reported_Age to determine if       │
│  interview was BEFORE or AFTER the person's birthday this year.             │
│                                                                             │
|  The goal is to Narrow the possible interview date window using each        |
|  person’s birthday and calculated age (by IBGE on the reference date of     |
|  the interview, which is the Saturday that ends the reference week).        |│                                                                             │
│  If AFTER birthday  -> date_min = max(date_min, Sat_after_birthday)         │
│  If BEFORE birthday -> date_max = min(date_max, Sat_before_birthday)        │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 3: Convert Date Ranges to Month Positions (1, 2, or 3)                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  month_min_pos = which month does date_min fall in?                         │
│  month_max_pos = which month does date_max fall in?                         │
│                                                                             │
│  Special handling: Weeks in which Saturdays fall on the 1st to 3rd day of   │
│  a month are assigned to the previous month.                                │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 4: Aggregate to UPA-Panel Level                                        │
├─────────────────────────────────────────────────────────────────────────────┤
│  All people in same (UPA, V1014) are interviewed in the SAME MONTH.         │
│  Take intersection of all individual constraints:                           │
│                                                                             │
│    upa_month_min = max(all individual month_min_pos)                        │
│    upa_month_max = min(all individual month_max_pos)                        │
│                                                                             │
│  If upa_month_min = upa_month_max -> DETERMINED!                            │
│  If upa_month_min < upa_month_max -> Still ambiguous, try Step 5            │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 5: Cross-Quarter Aggregation                                           │
├─────────────────────────────────────────────────────────────────────────────┤
│  PNADC uses ROTATING PANEL: same (UPA, V1014) interviewed in SAME MONTH     │
│  POSITION across all quarterly visits (up to 5 consecutive quarters).       │
│                                                                             │
│  Combine constraints from ALL quarters -> dramatically improves accuracy:   │
│                                                                             │
│    Per-quarter only:  ~65-75% determination                                 │
│    Cross-quarter:     ~97.0% determination                                  │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 6: Dynamic Exception Detection                                         │
├─────────────────────────────────────────────────────────────────────────────┤
│  Algorithm DYNAMICALLY detects which quarters need relaxed timing rules:    │
│                                                                             │
│  1. Calculate positions using STANDARD rules (>=4 days, day <=3 threshold)  │
│  2. Calculate positions using ALTERNATIVE rules (>=3 days, day <=2)         │
│  3. Detect: if standard produces min>max but alternative would work         │
│  4. Propagate: if ANY UPA needs exception -> apply to ALL in that quarter   │
│                                                                             │
│  Known exception quarters up to 2025q3 (detected automatically):            │
│  2016q3, 2016q4, 2017q2, 2022q3, 2023q2, 2024q1.                            │
└─────────────────────────────────────────────────────────────────────────────┘
                                     │
                                     ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ STEP 7: Final Month Assignment                                              │
├─────────────────────────────────────────────────────────────────────────────┤
│  After applying exceptions and recalculating:                               │
│  If upa_month_min == upa_month_max -> Reference month DETERMINED            │
│  Otherwise -> remains NA (indeterminate, ~3% of observations)               │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│ OUTPUT                                                                      │
├─────────────────────────────────────────────────────────────────────────────┤
│  ref_month_in_quarter: 1, 2, 3, or NA (indeterminate)                       │
│  ref_month:            Full date (e.g., 2023-02-01)                         │
│  ref_month_yyyymm:     Integer format (e.g., 202302)                        │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

### Step 1: Valid Interview Saturdays (IBGE Rules)

As previously stated, IBGE defines that a reference week belongs to a month only if it has at least **4 days within that month**. Since reference weeks end on Saturdays, we look at the Saturdays of each month to determine valid interview dates.

**How we calculate the first valid Saturday:**

```
first_saturday_day = day of the first Saturday of the month
if first_saturday_day >= 4:
    use this Saturday (it has enough days in the month)
else:
    use the second Saturday (first_saturday_day + 7)
```

**Example for Q1 2023:**

```
JANUARY 2023:
  Sun  Mon  Tue  Wed  Thu  Fri  SAT
   1    2    3    4    5    6   [7]  <- First Saturday is day 7
                                     7 >= 4? YES -> Valid! (7 days in January)

FEBRUARY 2023:
  Wed  Thu  Fri  SAT  ...
   1    2    3   [4]              <- First Saturday is day 4
                                  4 >= 4? YES -> Valid! (4 days in February)

APRIL 2023:
  SAT  Sun  Mon  Tue  ...
  [1]   2    3    4              <- First Saturday is day 1
                                  1 >= 4? NO -> Skip to second Saturday!
  Fri  SAT  Sun  ...
   7   [8]   9                   <- Use day 8 instead
```

The valid Saturday calculation defines the **possible interview date range** for the quarter:
- `date_min` = First valid Saturday of Month 1
- `date_max` = First valid Saturday of Month 3 + 21 days

---

### Step 2: Birthday Constraints

IBGE calculates age precisely using the precise birthdate and the interview reference date (and most persons inform birthdates). In other words, IBGE **calculates age on the Saturday** that ends the reference week of the interview. 

So, comparing the calculated age to the birth year, we can determine if the interview (i.e. the reference date) happened before or after the person's birthday that year. This allows us to further narrow down the possible interview date window.

```
visit_before_birthday = (Survey_Year - Birth_Year) - Calculated_Age

If = 0: Interview was AFTER birthday (person already celebrated this year)
If = 1: Interview was BEFORE birthday (birthday hasn't happened yet)
```

**Example: Interview AFTER birthday**

```
Person: Born March 15, 1990
Survey Year and quarter: 2023 Q1
Calculated Age: 33

Check age: 2023 - 1990 = 33
           33 - 33 = 0  -> Interview was AFTER March 15, 2023

Check first Saturday on or after birthday:
           first_Saturday_on_or_after(March 15) = March 18, 2023

New date constraints: 
            date_min = max(date_min, first_Saturday_on_or_after(March 15))                        
            date_min = max(Jan 7, March 18) = March 18

This person can only have been interviewed in MARCH (Month 3 of Q1).
```

**Example: Interview BEFORE birthday**

```
Person: Born February 17, 1990
Survey Year and quarter: 2023 Q1
Calculated Age: 32

Check age: 2023 - 1990 = 33
           33 - 32 = 1  -> Interview was BEFORE February 17, 2023

Check first Saturday on or after birthday:
           first_Saturday_on_or_after(February 17) = February 18, 2023

Constraint: date_max = min(date_max, Saturday_before(February 17))
            date_max = min(March 25, February 18) = February 18

This person can only have been interviewed in JANUARY or FEBRUARY.
```

**Unknown birthdays**: When V2008=99, V20081=99, or V20082=9999, that person's birthday cannot constrain the date. However, they may still be determined through aggregation by UPA-Panel level (Step 4) or cross-quarter aggregation (Step 5).

---

### Step 3: Date to Month Position

Transform the date window [date_min, date_max] into month-in-quarter positions (1, 2, or 3).

**Boundary handling**: Interviews on days 1-3 of a month typically belong to a reference week that started in the previous month:

```
For date_min: if day <= 3 AND not in first month of quarter:
              subtract 1 from month position

For date_max: if day <= 3:
              use the month of (date - 3 days) instead
```

---

### Step 4: UPA-Panel Aggregation

All people in the same **UPA + V1014** are interviewed together in the **same reference month**. Take the intersection:

```
upa_month_min = MAX of all individual month_min_pos
upa_month_max = MIN of all individual month_max_pos
```

**Example:**

```
A household located at UPA=123456 and member of the Panel group V1014=1 has 3 members:

Person A: month_min=1, month_max=2 (could be Jan or Feb)
Person B: month_min=1, month_max=3 (could be Jan, Feb, or Mar)
Person C: month_min=2, month_max=3 (could be Feb or Mar)

Aggregation:
  upa_month_min = max(1, 1, 2) = 2
  upa_month_max = min(2, 3, 3) = 2

Result: min=2, max=2 -> Reference month is FEBRUARY!

Visual:
              Jan    Feb    Mar
Person A:     [=========]
Person B:     [============]
Person C:            [========]
Intersection:        [==]      <- Only February satisfies all
```

---

### Step 5: Cross-Quarter Aggregation

Since the relative month position is constant across quarters, constraints from **any** quarter apply to **all** quarters:

```
For each (UPA, V1014) group across ALL quarters:
  upa_month_min = MAX of all month_min_pos from all quarters
  upa_month_max = MIN of all month_max_pos from all quarters
```

This is why processing stacked data improves determination from ~70% to ~97%.

---

### Step 6: Dynamic Exception Detection

In some quarters, the standard rule (first reference week with ≥4 days) may produce impossible results. For instance, `upa_month_min > upa_month_max`. Quarters in which this happens are flagged as needing an exception. We then implement an **alternative rule**: first reference week with ≥3 days

**How dynamic detection works**: The algorithm calculates month positions using both rules simultaneously:

| Rule | First reference week | Day Threshold |
|------|----------------------|---------------|
| Standard | >=4 days in month | day <= 3 |
| Alternative | >=3 days in month | day <= 2 |

Exceptions are detected and applied at the month level within each quarter. For example, in 2016q3, only month 3 (September) needs the exception -- months 1 and 2 use the standard rule. Here's why: under the standard rule, September's first valid Saturday would be September 10th (since September 3rd has only 3 days in the month). But some UPA-V1014 groups have constraints that require September 3rd to be valid. The exception rule (≥3 days instead of ≥4) makes September 3rd valid for these groups, assigning the week of August 28th-September 3rd to September's reference month rather than August's.

And the algorithm proceeds as follows:

```
For each UPA-V1014:
  1. Calculate upa_month_min/max using STANDARD rules
  2. Also calculate alt_upa_month_min/max using ALTERNATIVE rules
  3. If standard produces min > max (impossible) BUT alternative works:
     → This quarter requires an exception
  4. Determine WHICH month within the quarter needs the exception:
     - requires_exc_m1: Exception needed for month 1
     - requires_exc_m2: Exception needed for month 2
     - requires_exc_m3: Exception needed for month 3
  5. PROPAGATE: If ANY UPA in the quarter needs exception for a month,
     apply that exception to ALL observations in that quarter
```

Known exception quarters up to 2025q3: 2016q3, 2016q4, 2017q2, 2022q3, 2023q2, 2024q1.

---

### Step 7: Final Assignment

After applying exceptions: if `upa_month_min == upa_month_max`, the reference month is determined. Otherwise, it remains NA.

**What makes observations indeterminate (~3%)?**

This occurs when the available birth date information in a (UPA, V1014) group is insufficient to narrow down the possibilities to a single month. Several factors contribute:

- **Incomplete panel coverage**: Some UPAs may have fewer than the expected 5 visits in the dataset. The first and last 4 quarters of any consecutive series will naturally have more UPAs with incomplete visit histories due to the rotating panel design.
- **Unit non-response**: The survey targets 14 households per UPA each quarter, but non-response reduces this. Fewer responding households means fewer birthday constraints to narrow down the month.
- **Small household sizes**: Households with fewer members provide fewer birthday constraints.
- **Missing birth dates**: Not all respondents report their date of birth. Higher item non-response reduces the available constraints.
- **Uninformative birthdays**: Some reported birth dates don't help distinguish between months (e.g., birthdays outside the quarter's interview window).

Indeterminate observations are then removed from monthly analysis (if `keep_all = FALSE`) or assigned `month = NA` and `weight_monthly = NA` (if `keep_all = TRUE`).

---

## Monthly Weights

For monthly aggregate estimates, you need monthly-appropriate survey weights.

### How Weight Calibration Works

When `compute_weights = TRUE`, the package:

**1. Fetches monthly population from SIDRA API** (table 6022)

SIDRA provides **moving-quarter** population estimates, not exact monthly values:

| SIDRA Code | 3-Month Window | Represents Population For |
|------------|----------------|---------------------------|
| 201203 | Jan+Feb+Mar 2012 | **February 2012** |
| 201204 | Feb+Mar+Apr 2012 | **March 2012** |
| 201205 | Mar+Apr+May 2012 | **April 2012** |

The package shifts values to align with their center month. Boundary months (Jan 2012, latest month) are extrapolated via quadratic regression.

**2. Applies hierarchical rake weighting** across nested calibration cells:

| Cell Level | Definition | Purpose |
|------------|------------|---------|
| `celula1` | Age groups: 0-13, 14-29, 30-59, 60+ | Demographic balance |
| `celula2` | Post-stratum group + age | Regional-demographic balance |
| `celula3` | State (UF) + celula2 | State-level balance |
| `celula4` | Post-stratum (posest) + celula2 | Fine geographic balance |

At each level, weights are adjusted so monthly totals match quarterly totals proportionally.

**3. Calibrates to monthly population totals**

Final scaling ensures monthly weighted totals match SIDRA population (~206 million average).

### Usage Example

```{r monthly-weights}
# Load full data with all required variables
pnadc_full <- fread("pnadc_stacked_full.csv")

# Run mensalization with weight computation
result <- mensalizePNADC(pnadc_full, compute_weights = TRUE, verbose = TRUE)

# Use weight_monthly for monthly estimates
monthly_pop <- result[, .(
  population = sum(weight_monthly, na.rm = TRUE)
), by = ref_month_yyyymm]
```

### Handling Indeterminate Observations

By default (`keep_all = TRUE`), all input rows are returned, with `weight_monthly = NA` for indeterminate observations:

```{r keep-all-example}
# Default: returns all rows (indeterminate have weight_monthly = NA)
result <- mensalizePNADC(pnadc_full, compute_weights = TRUE)
nrow(result) == nrow(pnadc_full)  # TRUE - all rows returned
sum(is.na(result$weight_monthly))  # ~3% of rows have NA weights

# Use na.rm = TRUE when aggregating
monthly_pop <- result[, .(pop = sum(weight_monthly, na.rm = TRUE)), by = ref_month_yyyymm]

# Alternative: returns only determined rows
result_determined <- mensalizePNADC(pnadc_full, compute_weights = TRUE, keep_all = FALSE)
nrow(result_determined) < nrow(pnadc_full)  # TRUE (~97% of rows)
```

---

## Advanced Usage

### Using Modular Functions

For more control, use the individual functions:

```{r modular}
# Step 1: Just identify reference months
months <- identify_reference_month(pnadc)

# Step 2: Check determination rate by quarter
months[, .(
  total = .N,
  determined = sum(!is.na(ref_month_in_quarter)),
  rate = round(mean(!is.na(ref_month_in_quarter)) * 100, 1)
), by = .(Ano, Trimestre)]

# Step 3: Validate input data
validation <- validate_pnadc(pnadc, stop_on_error = FALSE)

# Step 4: Fetch population data from SIDRA-IBGE manually
pop_data <- fetch_monthly_population(verbose = TRUE)

# Step 5: Calibrate weights separately
calibrated <- calibrate_monthly_weights(merged_data, pop_data)
```

---

## Performance

### Benchmarks

| Dataset Size | Rows | Time (basic) | Throughput |
|--------------|------|--------------|------------|
| 1 quarter | ~570K | ~1.5 sec | ~380K rows/sec |
| 1 year | ~2.3M | ~5 sec | ~460K rows/sec |
| 14 years (2012-2025) | 28.4M | **~1 minute** | ~450K rows/sec |

**Key optimization**: The `make_date()` function uses pre-computed lookup tables instead of `ISOdate()`, achieving **20x speedup** on date operations.

### Determination Rates by Period

| Period | Quarters | Determination Rate | Notes |
|--------|----------|-------------------|-------|
| 2012 | Q1-Q4 | 91.8% - 98.9% | First year, panel rotation effects |
| 2013-2019 | 28 quarters | 96.1% - 99.0% | Best results, stable sampling |
| 2020-2021 | 8 quarters | 93.0% - 97.5% | Pandemic sample changes |
| 2022-2024 | 12 quarters | 91.3% - 95.6% | Post-pandemic normalization |
| 2025 | Q1-Q3 | 88.9% - 95.9% | Most recent data |

**Why boundary quarters have lower rates**: The first 4 and last 4 quarters of any consecutive quarterly dataset will always include (UPA, V1014) groups with fewer than 5 visits in the data. This makes mensalization efficiency suboptimal at the boundaries. In a dataset with 9 consecutive quarters, for example, only the 5th quarter will have full utilization -- because among people observed in the 5th quarter, all of them will have all their visits in the data, from those on their 1st visit in the 5th quarter to those on their 5th visit in the 5th quarter. This is an inherent consequence of PNADC's rotating panel design (5 visits over 5 quarters).

### Optimization Tips

- Use `data.table` directly (automatic conversion from `data.frame` adds overhead)
- Load only required columns when reading data
- Process multiple years together (cross-quarter aggregation improves accuracy)

---

## Tips and Best Practices

1. **Process multiple quarters together**: Processing 2012-2025 together gives ~97% determination vs ~70% per-quarter.

2. **Start with reference month identification**: You don't always need monthly weights. Often just knowing the reference month is enough.

3. **Check determination rates by year**: Rates should be 96-99% for 2013-2019. Lower rates may indicate data issues.

   ```{r check-rates}
   crosswalk[, .(rate = mean(!is.na(ref_month_in_quarter))), by = .(Ano, Trimestre)]
   ```

4. **Handle indeterminate observations**: Decide whether to exclude them or use quarterly-level analysis for those cases.

5. **Use `weight_monthly` for general analysis**: The rake-weighted output is appropriate for most purposes.

---

## Further Reading

- [Applied Examples](applied-examples.html) - See the algorithm in action with COVID, recession, and minimum wage validation
- [IBGE PNADC Documentation](https://www.ibge.gov.br/estatisticas/sociais/trabalho/9171-pesquisa-nacional-por-amostra-de-domicilios-continua-mensal.html)
- Package function reference: `?mensalizePNADC`, `?identify_reference_month`
- Source code: [GitHub repository](https://github.com/antrologos/mensalizePNADC)
