---
title: "Monthly Poverty Analysis with Annual PNADC Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Monthly Poverty Analysis with Annual PNADC Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!--
MAINTAINER NOTE:
The code chunks in this vignette must match the code in:
  mensalizacao_pnad/code/generate_annual_poverty_figures.R

Look for comments like "# VIGNETTE CODE: chunk-name" in that script.
To regenerate figures, run that script. Changes to code here
must be mirrored in the generation script (and vice versa).

Run code/check_vignette_sync.R to verify synchronization before release.
-->

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  eval = FALSE,
  echo = TRUE,
  collapse = TRUE,
  comment = "#>",
  message = FALSE,
  warning = FALSE,
  fig.width = 10,
  fig.height = 6,
  purl = FALSE
)
```

## Prerequisites

This vignette requires the following packages:

```{r prerequisites}
# Core packages
library(PNADCperiods)
library(data.table)
library(fst)

# For deflation
library(readxl)      # Read deflator Excel files
library(deflateBR)   # INPC deflator

# For survey analysis
library(survey)

# For visualization
library(ggplot2)
library(scales)
library(patchwork)   # Combine plots
library(Hmisc)       # wtd.mean
```

You also need:

- **Quarterly PNADC data** (2015-2024) in `.fst` format for creating the mensalization crosswalk
- **Annual PNADC data** (2015-2024) in `.fst` format with income supplement variables
- **Deflator file** from IBGE documentation (`deflator_pnadc_2024.xls`)

---

## Introduction

When exactly did poverty spike during COVID-19? Official annual statistics tell us that 2020 was a difficult year---but they can't tell us whether the crisis peaked in April, May, or June. They can't reveal whether the Auxílio Emergencial (emergency cash transfers) reduced poverty immediately upon implementation or with a delay. And they can't show us the month-by-month path of recovery.

**Monthly data can.**

This vignette demonstrates a powerful technique: combining the mensalization algorithm with **annual PNADC data** to produce monthly poverty statistics. The annual PNADC releases contain comprehensive household income measures that aren't available in the quarterly releases. By merging a mensalization crosswalk (from quarterly data) with annual income data, we get the best of both worlds: monthly temporal precision with comprehensive income measurement.

![Data Workflow: Monthly Poverty Analysis with Annual PNADC](figures/annual-poverty-analysis/fig-workflow-diagram.png){width=100%}

### Why This Works

IBGE's PNADC uses a rotating panel design. The same households are interviewed in both quarterly and annual data collection. This means we can:

1. Identify which reference month each observation belongs to (using the quarterly data)
2. Merge this information with annual income data (using household/person identifiers)
3. Analyze detailed income and poverty measures at monthly frequency

### What You'll Learn

- How to create a mensalization crosswalk from quarterly data
- How to merge the crosswalk with annual PNADC income data
- How to construct per capita household income and poverty measures
- How to analyze monthly poverty dynamics during the 2015-2024 period

---

## Quick Start

If you want to see the end result before diving into the methodology, here's what monthly poverty analysis reveals:

```{r quick-preview, eval=FALSE}
# Load pre-computed monthly poverty estimates
monthly_poverty <- fst::read_fst("monthly_poverty_aggregates.fst",
                                  as.data.table = TRUE)

# Monthly poverty rate for March 2020 (COVID onset)
monthly_poverty[ref_month_yyyymm == 202003, poverty_rate]
#> [1] 0.25  # ~25% below USD 8.30/day poverty line

# Compare to December 2020 (after Auxílio Emergencial)
monthly_poverty[ref_month_yyyymm == 202012, poverty_rate]
#> [1] 0.19  # Reduced due to emergency transfers
```

The rest of this vignette explains how to produce these estimates from raw PNADC data.

---

## Data Strategy

### The Crosswalk Concept

The mensalization algorithm determines which specific month an interview refers to by analyzing birthday constraints and IBGE's interview scheduling rules. However, this algorithm requires the quarterly data format---specifically, variables like `V2008` (birth day), `V20081` (birth month), and `V20082` (birth year) that aren't always available in annual releases.

The solution is a **crosswalk**: we run mensalization on quarterly data to get reference months, then merge the results with annual data using household and person identifiers.

### Join Keys

The quarterly and annual PNADC releases share the same sampling units and can be linked using six key variables:

```{r join-keys}
# Join keys between quarterly and annual PNADC
# Note: Variable names are converted to lowercase during processing
join_keys <- c("ano", "trimestre", "upa", "v1008", "v1014", "v2003")

# ano:       Survey year
# trimestre: Quarter (1-4)
# upa:       Primary Sampling Unit (census tract)
# v1008:     Household selection number within UPA
# v1014:     Panel group (1-8, identifies rotation cohort)
# v2003:     Person order within household
```

### Match Rate and Missing Observations

When merging the crosswalk with annual data, expect approximately **97% of observations** to have a determined reference month. The remaining ~3% occur because:

- Some observations fall in edge cases where the mensalization algorithm cannot determine a unique month
- Minor inconsistencies between quarterly and annual data collection

For poverty analysis, we recommend **dropping observations without determined reference months**. This is the cleanest approach and introduces minimal bias since the undetermined cases are essentially random across the income distribution.

---

## Required Variables

### From Quarterly Data (for mensalization)

| Variable | Description |
|----------|-------------|
| `Ano`, `Trimestre` | Time period identifiers |
| `UPA`, `V1008`, `V1014`, `V2003` | Household/person join keys |
| `V2008`, `V20081`, `V20082` | Birthday (day, month, year) |
| `V2009` | Age |
| `V1028` | Original survey weight |
| `UF`, `posest`, `posest_sxi` | For weight calibration |

### From Annual Data (for poverty analysis)

| Variable | Description | Category |
|----------|-------------|----------|
| `vd5008` | Household per capita income | Income |
| `v2005` | Position in household | Filter |
| `v2009` | Age | Demographics |
| `v1032` | Survey weight | Design |
| `uf` | State | Geography |
| `estrato` | Survey stratum | Design |
| `posest` | Post-stratum | Calibration |
| `posest_sxi` | Post-stratum auxiliary | Calibration |

> **Why VD5008?** IBGE pre-calculates this variable to include all income sources
> (labor, transfers, pensions, other) and divides by household size. Using VD5008
> directly ensures consistency with official IBGE statistics and simplifies the
> workflow.

---

## Complete Workflow

### Step 1: Create Mensalization Crosswalk

First, load stacked quarterly PNADC data and run the mensalization algorithm:

```{r create-crosswalk}
library(PNADCperiods)
library(data.table)
library(fst)

# Define paths
pnad_quarterly_dir <- "path/to/quarterly/data"

# List quarterly files (2015-2024)
quarterly_files <- list.files(
  path = pnad_quarterly_dir,
  pattern = "PNADC_.*\\.fst$",
  full.names = TRUE
)

# Variables needed for mensalization
quarterly_vars <- c(
  "Ano", "Trimestre", "UPA", "V1008", "V1014", "V2003",
  "V2008", "V20081", "V20082", "V2009",
  "V1028", "UF", "posest", "posest_sxi", "Estrato"
)

# Load and stack quarterly data
quarterly_data <- rbindlist(
  lapply(quarterly_files, function(f) {
    read_fst(f, as.data.table = TRUE, columns = quarterly_vars)
  }),
  fill = TRUE
)

# Build the crosswalk (identifies reference periods)
crosswalk <- pnadc_identify_periods(
  quarterly_data,
  verbose = TRUE
)

# Check determination rate
mean(!is.na(crosswalk$ref_month_in_quarter))
#> [1] 0.97  # ~97% of observations have determined reference months
```

### Step 2: Load Annual PNADC Data

Annual PNADC files follow a specific naming convention. Note that 2020-2021 use visit 5 (due to COVID-related field disruptions), while other years use visit 1:

```{r load-annual-data}
pnad_annual_dir <- "path/to/annual/data"

# Define which visit to use for each year
visit_selection <- data.table(
  ano = 2015:2024,
  visita = c(1, 1, 1, 1, 1, 5, 5, 1, 1, 1)  # 2020-2021 use visit 5
)
```

> **Why Visit 5 for 2020-2021?**
>
> During COVID-19, IBGE suspended in-person data collection. Visit 1 interviews
> for 2020-2021 have significant quality issues or are unavailable entirely.
> Visit 5 interviews were conducted later under improved conditions and are
> the standard choice for COVID-era income and poverty analysis. This follows
> IBGE's own recommendations for annual income analysis during this period.

```{r load-annual-data-continued}

# Build file paths
annual_files <- visit_selection[, .(
  file = file.path(pnad_annual_dir, sprintf("pnadc_%d_visita%d.fst", ano, visita))
), by = ano]

# Variables to load
annual_vars <- c(
  # Join keys
  "ano", "trimestre", "upa", "v1008", "v1014", "v2003",
  # Demographics
  "v2005", "v2007", "v2009", "v2010", "uf", "estrato",
  # Weights and calibration
  "v1032", "posest", "posest_sxi",
  # Household per capita income (IBGE pre-calculated)
  "vd5008"
)

# Load and stack annual data
annual_data <- rbindlist(
  lapply(annual_files[file.exists(file), file], function(f) {
    dt <- read_fst(f, as.data.table = TRUE)
    setnames(dt, tolower(names(dt)))
    cols_present <- intersect(annual_vars, names(dt))
    dt[, ..cols_present]
  }),
  fill = TRUE
)
```

### Step 3: Merge Crosswalk with Annual Data and Calibrate Weights

Now merge the mensalization results with the annual income data and calibrate weights:

```{r merge-crosswalk}
# Apply crosswalk to annual data and calibrate V1032 weights
d <- pnadc_apply_periods(
  annual_data,
  crosswalk,
  weight_var = "V1032",
  anchor = "year",
  calibrate = TRUE,
  verbose = TRUE
)
#> Applying crosswalk...
#> Match rate: 97.0%
#> Calibrating weights...
#>   Fetching monthly population from SIDRA...
#>   Calibrated 28,456,123 observations

# Check match rate
mean(!is.na(d$ref_month_in_quarter))
#> [1] 0.97
```

> **Why use `pnadc_apply_periods(..., anchor = "year")` instead of manual merge?**
>
> The quarterly crosswalk produces `weight_monthly` by calibrating the quarterly
> weight **V1028**, which assumes all 5 rotation groups are present in each quarter
> (~20% of observations from each panel visit).
>
> Annual data contains only **one visit** per household (e.g., visit 1 or visit 5),
> so using V1028-based weights would severely misrepresent the population---each
> observation would be weighted as if it represents only 1/5 of its demographic cell.
>
> `pnadc_apply_periods()` with `anchor = "year"` properly calibrates the **annual weight V1032** to monthly
> SIDRA population totals using hierarchical rake weighting. This ensures that:
>
> - Weights sum to correct monthly population totals
> - Demographic cells are balanced within each year
> - Results are comparable to official IBGE statistics
>
> For technical details on how annual weight calibration differs from quarterly,
> see the [How It Works](how-it-works.html#mensalizing-annual-pnadc-data) vignette.

### Step 4: Construct Per Capita Income

Use IBGE's pre-calculated household per capita income variable:

```{r construct-income}
# Filter to household members only
d <- d[v2005 <= 14 | v2005 == 16]

# Create household ID
d[, id_dom := paste(upa, v1008, v1014, sep = "_")]

# Use IBGE's pre-calculated per capita household income
# VD5008 already accounts for all income sources and household size
d[, hhinc_pc_nominal := fifelse(is.na(vd5008), 0, vd5008)]
```

### Step 5: Apply Deflation

Convert nominal income to real values using IBGE deflators:

```{r apply-deflation}
# Load deflator data (from IBGE documentation)
deflator <- readxl::read_excel("path/to/deflator_pnadc_2024.xls")
setDT(deflator)
deflator <- deflator[, .(ano, trimestre = trim, uf, CO2, CO2e, CO3)]

# Merge deflators with data
setkeyv(deflator, c("ano", "trimestre", "uf"))
setkeyv(d, c("ano", "trimestre", "uf"))
d <- deflator[d]

# INPC adjustment factor to reference date (December 2025)
inpc_factor <- deflateBR::inpc(1,
                               nominal_dates = as.Date("2024-07-01"),
                               real_date = "12/2025")

# Apply deflation
d[, hhinc_pc := hhinc_pc_nominal * CO2 * inpc_factor]
```

### Step 6: Define Poverty Line

Calculate the World Bank PPP-based poverty threshold:

```{r define-poverty-lines}
# World Bank poverty line: USD 8.30 PPP per day (upper-middle income threshold)
poverty_line_830_ppp_daily <- 8.30

# 2021 PPP conversion factor (World Bank)
# https://data.worldbank.org/indicator/PA.NUS.PRVT.PP?year=2021
usd_to_brl_ppp <- 2.45
days_to_month <- 365/12

# Monthly value in 2021 BRL
poverty_line_830_brl_monthly_2021 <- poverty_line_830_ppp_daily *
                                     usd_to_brl_ppp * days_to_month

# Deflate to December 2025 reference
poverty_line_830_brl_monthly_2025 <- deflateBR::inpc(
  poverty_line_830_brl_monthly_2021,
  nominal_dates = as.Date("2021-07-01"),
  real_date = "12/2025"
)

d[, poverty_line := poverty_line_830_brl_monthly_2025]
```

> **Why USD 8.30/day?** This is the World Bank's upper-middle income poverty
> threshold, appropriate for Brazil. We use the 2021 PPP conversion factor
> (2.45 BRL per USD) which is the most recent available.

---

## Analysis Examples

### Helper Functions

Before computing poverty measures, we define the FGT family of poverty indices:

```{r helper-functions}
# FGT poverty measure family (Foster-Greer-Thorbecke)
# alpha = 0: Headcount ratio (share below line)
# alpha = 1: Poverty gap (average shortfall)
# alpha = 2: Squared poverty gap (sensitive to inequality among poor)
fgt <- function(x, z, w = NULL, alpha = 0) {
  if (is.null(w)) w <- rep(1, length(x))
  if (length(z) == 1) z <- rep(z, length(x))

  idx <- complete.cases(x, z, w)
  x <- x[idx]; z <- z[idx]; w <- w[idx]

  g <- pmax(0, (z - x) / z)
  fgt_val <- ifelse(x < z, g^alpha, 0)

  sum(w * fgt_val) / sum(w)
}
```

### Example 1: Monthly FGT Poverty Measures

Calculate monthly poverty rates using the FGT family:

```{r example-fgt-family}
# Filter to determined observations
d_monthly <- d[!is.na(ref_month_yyyymm)]

# Use calibrated monthly weight (from mensalize_annual_pnadc())
d_monthly[, peso := weight_monthly]

# Compute monthly poverty statistics
monthly_poverty <- d_monthly[, .(
  # FGT-0 (Headcount ratio)
  poverty_rate = fgt(hhinc_pc, poverty_line, peso, alpha = 0),

  # FGT-1 (Poverty gap)
  poverty_gap = fgt(hhinc_pc, poverty_line, peso, alpha = 1),

  # Mean income
  mean_income = wtd.mean(hhinc_pc, peso),

  # Sample size
  n_obs = .N

), by = ref_month_yyyymm]

# Add date for plotting
monthly_poverty[, period := as.Date(paste0(
  ref_month_yyyymm %/% 100, "-",
  ref_month_yyyymm %% 100, "-15"
))]
```

![Monthly Poverty Measures: Brazil, 2015-2024](figures/annual-poverty-analysis/fig-fgt-monthly-series.png){width=100%}

The figure reveals several key dynamics:

1. **Pre-COVID baseline**: Poverty rates were gradually declining from 2015-2019, recovering from the 2015-2016 recession.

2. **COVID-19 spike (March-April 2020)**: The poverty rate shows a sharp increase in early 2020.

3. **Auxílio Emergencial effect (May-December 2020)**: Emergency cash transfers dramatically reduced poverty below pre-pandemic levels.

4. **Post-Auxílio adjustment (2021)**: As emergency aid was reduced, poverty rates partially rebounded.

### Example 2: Survey Design (Brief)

For proper inference, use complex survey design with monthly weights:

```{r example-survey-design}
library(survey)

# Create survey design for one month (e.g., March 2020)
march_2020 <- d_monthly[ref_month_yyyymm == 202003]

design <- svydesign(
  ids = ~upa,
  strata = ~estrato,
  weights = ~peso,
  data = march_2020,
  nest = TRUE
)

# Poverty rate with confidence interval
poverty_estimate <- svymean(
  ~I(hhinc_pc < poverty_line),
  design,
  na.rm = TRUE
)

confint(poverty_estimate)
```

For detailed guidance on variance estimation with monthly weights, including the replication weights approach, see the [Complex Survey Design](complex-survey-design.html) vignette.

### Example 3: Post-hoc Smoothing of Aggregates

The raw monthly series may show quarterly artifacts from IBGE's rotating panel design. If artifacts persist after weight calibration (which applies smoothing by default), you can apply additional post-hoc smoothing to your aggregated estimates:

```{r example-smoothing}
# Three-month centered rolling average (using data.table::frollmean)
monthly_poverty[, poverty_rate_smoothed :=
                  frollmean(poverty_rate, 3, align = "center")]
```

![Raw vs Smoothed Monthly Poverty Rate](figures/annual-poverty-analysis/fig-smoothing-comparison.png){width=100%}

**Caution**: Smoothing removes noise but may also mask real month-to-month dynamics. Use smoothing for trend visualization, but report raw estimates for specific months of interest.

---

## Summary

| Insight | Annual Data | Monthly Data |
|---------|-------------|--------------|
| **COVID poverty spike** | Averaged across year | Visible March-April 2020 |
| **Auxílio timing** | Effect blurred | Clear May 2020 onset |
| **Recovery dynamics** | Single 2021 estimate | Monthly trajectory |
| **Seasonal patterns** | Invisible | December income spikes |

### When to Use This Approach

- **Event studies**: Analyzing policy changes or economic shocks with precise timing
- **Policy evaluation**: Measuring immediate effects of interventions (e.g., cash transfers)
- **Seasonal analysis**: Identifying within-year patterns in poverty
- **Nowcasting**: Producing more timely poverty estimates

### Limitations

- **Sample loss**: ~3% of observations have undetermined reference months
- **Data lag**: Annual PNADC is released with 18+ month delay
- **Variable changes**: Pre-2015 annual data uses different variable names
- **Confidence intervals**: Monthly estimates have wider uncertainty than annual

---

## Further Reading

- [Get Started](getting-started.html) - Basic mensalization workflow
- [How It Works](how-it-works.html) - Algorithm details
- [Complex Survey Design](complex-survey-design.html) - Variance estimation
- [Applied Examples](applied-examples.html) - Unemployment and minimum wage examples

---

## References

- IBGE. Pesquisa Nacional por Amostra de Domicílios Contínua (PNADC). https://www.ibge.gov.br/estatisticas/sociais/trabalho/
- World Bank. Poverty and Shared Prosperity Reports. Various years.
- Foster, J., Greer, J., & Thorbecke, E. (1984). A class of decomposable poverty measures. *Econometrica*, 52(3), 761-766.
